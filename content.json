{"posts":[{"title":"ABC255比赛笔记","text":"比赛传送门 前言做出来 7 题，第一次做出 Ex，感觉还不错。 上一次做出 7 题还是在很久以前呢 /wx 为啥 ABC 前几题越来越难了啊，感觉 C 都有 D 的水平了。 交错程序一发，可真有我的。 题解A - You should output ARC, though this is ABC.题目名字好废话，看个乐子就好。 B - Light It Up题意给定若干个点，其中一些点上有灯，灯能照到半径为 $R$ 的圆内的地方。求要找到所有点，$R$ 的最小值，$N\\le 1000$。 做法对于每个点找离它最近的灯，把所有距离取 $\\max$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 0x3f3f3f3f#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); }void err(istream_iterator&lt;string&gt; it) {}template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) { cerr &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; '=' &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl; err(++it, args...);}int T_, case_;int n, k, a;bool f[1010];double x[1010], y[1010], mn, ans = 0;void solve() { cin &gt;&gt; n &gt;&gt; k; rep(i, k)cin &gt;&gt; a, f[a - 1] = 1; rep(i, n)cin &gt;&gt; x[i] &gt;&gt; y[i]; rep(i, n) { mn = MAXN; rep(j, n) { if (!f[j])continue; mn = min(mn, sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]))); } ans = max(ans, mn); } cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; ans;}int main() { T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} C - ±1 Operation 1题意给定一个等差数列的首项 $A$，公差 $D$ 和项数 $N$，每次操作可以将 $X+1$ 或 $-1$。求最少要多少次操作才能使 $X$ 和等差数列中某个数相等。 $N\\le 10^{12},-10 ^6 \\le D \\le 10^6, -10^{18} \\le X,A\\le 10^{18}$ 做法首先，如果 $D=0$，那么 $X$ 只能变成 $A$，输出 $\\left| X-A\\right|$ 即可。 如果 $D&lt;0$，则把 $A$ 变成 $A+D\\cdot (N-1)$，把 $D$ 变成 $-D$，这样就转化成 $D&gt;0$ 的情况了。 现在已经保证了 $D&gt;0$，所以就找出离 $X$ 最近的在等差数列中的值 $Y$，用 $\\left| X-Y\\right|$ 更新答案，FG 因为不会考虑边界就直接左右多偏移几个，注意判断超出等差数列的情况。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 0x3f3f3f3f#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); }void err(istream_iterator&lt;string&gt; it) {}template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) { cerr &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; '=' &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl; err(++it, args...);}int T_, case_;ll x, a, d, n, y, ans = -1;void solve() { cin &gt;&gt; x &gt;&gt; a &gt;&gt; d &gt;&gt; n; if (!d) { cout &lt;&lt; abs(x - a); return; } if (d &lt; 0) { a += d * (n - 1); d *= -1; } if (x &gt;= a) { y = a + (x - a) / d * d; for (ll z = y - d * 3;z &lt;= y + d * 3;z += d) { if (z&lt;a || z&gt;a + d * (n - 1))continue; if (ans == -1 || ans &gt; abs(x - z))ans = abs(x - z); } } ll z; z = a; if (ans == -1 || ans &gt; abs(x - z))ans = abs(x - z); z = a + d * (n - 1); if (ans == -1 || ans &gt; abs(x - z))ans = abs(x - z); cout &lt;&lt; ans;}int main() { T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} D - ±1 Operation 2题意给定一个长度为 $N$ 的数组 $A$，每次操作可以把其中一个数 $+1$ 或 $-1$，有 $Q$ 次查询，第 $i$ 次询问最少多少次可以全部变成 $X_i$。 $N,Q \\le 2\\times 10^5,A_i,X_i \\le 10^9$ 做法先排序，处理出前缀和。 查询时先 lower_bound 出有 $P$ 个数 $&lt; X_i$，用前缀和处理，这部分答案就是 $P\\cdot X_i-sum_p$，其余的 $\\ge X_i$ 的部分同理。 Code123456789101112131415161718192021222324252627282930313233343536373839404142/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 0x3f3f3f3f#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); }void err(istream_iterator&lt;string&gt; it) {}template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) { cerr &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; '=' &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl; err(++it, args...);}int T_, case_;int n, q;ll a[200005], x, sum[200005];void solve() { cin &gt;&gt; n &gt;&gt; q; repp(i, n)cin &gt;&gt; a[i]; sort(a + 1, a + 1 + n); repp(i, n)sum[i] = sum[i - 1] + a[i]; while (q--) { cin &gt;&gt; x; ll p = upper_bound(a + 1, a + 1 + n, x) - a; cout &lt;&lt; (p - 1) * x - sum[p - 1] + (sum[n] - sum[p - 1]) - (n - p + 1) * x &lt;&lt; endl; }}int main() { T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} E - Lucky Numbers题意有一个未知的长度为 $N$ 的数列 $A$ 满足 $A_i+A_{i+1}=S_i$，给定 $S$ 和一个大小为 $M$ 的集合 $X$，求最多有多少个 $i$ 满足 $A_i \\in X$。 $N \\le 10^6,M \\le 10,-10^9 \\le S_i,X_i \\le 10^9$ 做法先钦定 $A_1=0$，推出整个 $A$。 容易得到，如果 $A_1+1$，那么必定会有 $A_2-1,A_3+1,A_4-1,A_5+1\\dots$，即奇数下标的 $+1$，偶数下标的 $-1$。 对于每个奇数的 $i$ 处理出所有 $X_j-A_i$，对于每个偶数的 $i$ 处理出所有 $A_i-X_j$，这样就可以统计出 $A_1+W$ 后的答案，即为 $W$ 在统计中出现的次数。在左右出现次数中取最大值即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (ll i = a; i &lt;= b; i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 0x3f3f3f3f#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); }void err(istream_iterator&lt;string&gt; it) {}template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) { cerr &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; '=' &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl; err(++it, args...);}ll T_, case_;ll n, m, s[100005], x[20], a[100005], ans = 0;vector&lt;ll&gt;v;void solve() { cin &gt;&gt; n &gt;&gt; m; rep(i, n - 1)cin &gt;&gt; s[i]; rep(i, m)cin &gt;&gt; x[i]; forr(i, 1, n - 1)a[i] = s[i - 1] - a[i - 1]; rep(i, n) { rep(j, m) { ll tmp; if (i % 2 == 0)tmp = a[i] - x[j]; else tmp = x[j] - a[i]; v.pb(tmp); } } sort(v.begin(), v.end()); ll l, r = 0; while (r &lt; (ll)v.size()) { l = r; while (r + 1 &lt; (ll)v.size() &amp;&amp; v[r + 1] == v[l])r++; ans = max(ans, r - l + 1); r++; } cout &lt;&lt; ans;}int main() { T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} F - Pre-order and In-order题意给出一棵树的前序遍历 $P$ 和中序遍历 $I$，求这棵树的形态，或判断无解。 $N \\le 2\\times 10^5$ 做法CSP 初赛经典题了属于是。 考虑 $P_{l\\dots r}$ 匹配 $I_{L\\dots R}$。 显然 $P_l$ 为根，所以就可将 $I$ 划分成两段，即 $P_l$ 的左边和右边。知道左右子树大小后，就可以将 $P_{L+1\\dots R}$ 划分成两段，递归即可。 如果 $P_l$ 在 $I_{L\\dots R}$ 中没有出现则判断无解。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 0x3f3f3f3f#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); }void err(istream_iterator&lt;string&gt; it) {}template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) { cerr &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; '=' &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl; err(++it, args...);}int T_, case_;int n, a[200005], b[200005], p[200005];int son[200005][2];bool ans = 1;void dfs(int l, int r, int L, int R) { if (l &gt; r || L &gt; R || !ans)return; int x = a[l], y = p[a[l]], lenl = y - L, lenr = R - y; if (y&lt;L || y&gt;R)ans = 0; if (lenl &gt; 0)son[x][0] = a[l + 1] + 1, dfs(l + 1, l + lenl, L, y - 1); if (lenr &gt; 0)son[x][1] = a[l + lenl + 1] + 1, dfs(l + lenl + 1, r, y + 1, R);}void solve() { cin &gt;&gt; n; rep(i, n)cin &gt;&gt; a[i], a[i]--; rep(i, n)cin &gt;&gt; b[i], b[i]--, p[b[i]] = i; if (a[0]) { cout &lt;&lt; -1; return; } dfs(0, n - 1, 0, n - 1); if (!ans)cout &lt;&lt; -1; else rep(i, n)cout &lt;&lt; son[i][0] &lt;&lt; ' ' &lt;&lt; son[i][1] &lt;&lt; endl;}int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} G - Constrained Nim没看。 Ex - Range Harvest Query题意有 $N$ 棵树，第 $0$ 天它们都没有果子，每天晚上，第 $i$ 棵树会结出 $i$ 个果子。 共有 $Q$ 次采摘，第 $i$ 次在第 $D_i$ 天晚上，采走第 $L_i$ 到 $R_i$ 棵树上所有的果子。 对于每次采摘，输出采到了多少果子，对 $998244353$ 取模。 $N,D_i \\le 10^{18},Q \\le 2 \\times 10^5,D_i&lt;D_{i+1}$ 做法珂朵莉树模板题。 感谢 lxl！ 维护每棵树最后被采摘的区间，每次用等差数列求和处理区间贡献，再区间赋值即可。 由于每次操作只会 split 出 至多 $2$ 个区间，所以区间总数是 $O(Q)$ 的，并且查询复杂度和包含的区间个数有关，查询后会将这些区间全部合并到一起，所以最多只会查询 $O(Q)$ 个区间，算上 set 复杂度，总时间复杂度为 $O(Q \\log Q)$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 0x3f3f3f3f#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); }void err(istream_iterator&lt;string&gt; it) {}template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) { cerr &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; '=' &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl; err(++it, args...);}int T_, case_;struct Node { ll l, r; mutable ll val; Node(ll a = -1, ll b = -1, ll c = 0) { l = a, r = b, val = c; } bool operator &lt; (const Node&amp; a) const { return l &lt; a.l; }};set&lt;Node&gt;s;bool cmp(pair&lt;ll, ll&gt;x, pair&lt;ll, ll&gt;y) { return x.first &lt; y.first;}set&lt;Node&gt;::iterator split(ll pos) { set&lt;Node&gt;::iterator it = s.lower_bound(Node(pos)); if (it != s.end() &amp;&amp; it-&gt;l == pos)return it; --it; Node tmp = *it; s.erase(it); s.insert(Node(tmp.l, pos - 1, tmp.val)); return s.insert(Node(pos, tmp.r, tmp.val)).first;}void assign(ll l, ll r, ll val) { set&lt;Node&gt;::iterator itr = split(r + 1), itl = split(l); s.erase(itl, itr); s.insert(Node(l, r, val));}ll qpow(ll a, ll x, ll y) { ll ans = 1; a %= y; while (x) { if (x &amp; 1)ans = (ans * a) % y; a = (a * a) % y; x &gt;&gt;= 1; } return ans;}ll e_2;ll query(ll l, ll r, ll d) { set&lt;Node&gt;::iterator itr = split(r + 1), itl = split(l); ll ans = 0; for (set&lt;Node&gt;::iterator it = itl; it != itr; it++) { ll L = it-&gt;l, R = it-&gt;r, lst = it-&gt;val; ll sum = (L % MOD + R % MOD) % MOD * ((R - L + 1) % MOD) % MOD * e_2 % MOD; ans = (ans + (d % MOD - lst) % MOD * sum % MOD) % MOD; } return (ans + MOD) % MOD;}ll n, q, d, l, r;void solve() { e_2 = qpow(2, MOD - 2, MOD); cin &gt;&gt; n &gt;&gt; q; s.insert(Node(1, n, 0)); while (q--) { cin &gt;&gt; d &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(l, r, d) &lt;&lt; endl; assign(l, r, d); }}int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} 后记赛后难度出来了，果然 G&gt;Ex 呢 /hx","link":"/2023/01/06/ABC255%E6%AF%94%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"title":"2022&#x2F;7&#x2F;15模拟赛记","text":"ych 出的模拟赛。 /bx /bx /bx 原题场 /fn /fn /fn 赛时T1 string 发现是 NOIP 原题，然而忘记自己做过了。 想了一会发现自己做过，但是 ych 这个【】居然卡常，1e6-&gt;3e6 /oh 然而自己之前写的是 BIT，吸氧后 900+ms，感觉有点危险，写了个 $O(n\\ln n+n\\cdot 26)$ 的，感觉也许能过。 ych 啊 ych，既然已经加强数据范围了就不要出毒瘤数据了吧。 预估 100pts T2 work上午刚做过 P4158 粉刷匠，就只想着背包了。 然后就写了个背包，复杂度 $O(na^2nb^2n)$，感觉很危险，有可能能过。 预估 80pts T3 sort一开始瞎推推出来个 _逆序对数+递归层数_，然而这玩意居然是能过样例的。 写了个暴力对拍下，发现错了，然后白兰去看 T4 了。 最后 30min 随便想了一个结论：每个点到最后面的比它小的点的距离之和，发现能过样例，和暴力拍拍也对的 /xia 最后造了个 2000 个 1e9 的数据，发现输出 0，于是写了个特判原数组已经有序就输出 $n$。 用 BIT 实现的，复杂度 $O(n \\log n)$，1e5 的数据应该轻松。 预估 100pts T4 magic想到 mod 不能约分，直接放弃。 预估 0pts 总分预估 100+80+100+0=280pts 赛后T1 被卡 T 成 80pts，T2,3,4 发挥稳定 总分 80+80+100+0=260pts 发现 T2 正解实际上要二分，有单谷性质 /px 蓝 /bx T3 居然结论猜对了 T4 矩阵乘法，维护前缀后缀积，然而 ych 卡带 log 的线段树做法 /baojin ych 没开 O2，重测 /fn /fn /fn 吸氧后 T1 过了。 O2 /qiang 总分 100+80+100+0=280pts 以下为第二天 gzy T3 被卡后发现我的也挂了 successful hack! gzy /bx 总分 100+80+90+0=270pts T1 被 sanwei 卡成 96 分。 反正本来也过不了的。 总分 96+80+90+0=266pts sanwei /bx Links贴下原题链接吧 T1 string NOIP2020 字符串匹配 T2 work WC2001 高性能计算机 T3 sort USACO18OPEN Out of Sorts P T4 magic 「LibreOJ NOI Round #2」单枪匹马 打的太差就不贴代码了 另附 ych 写的题解，如果像我一样觉得出题人很可爱的可以不看 # 题解 A.string题意给定字符串 $S$，求把 $S$ 拆分为 $ABAB…ABC$ 这样的形式的方案数。 做法考虑枚举 $AB$ 的长度，用 $Z$ 函数求出最多连续 $AB$ 作为前缀的数量。 考虑 $C$ 中出现奇数次的字母的个数，发现对于 $AB$ 长度固定时只有两种取值，和选的 $AB$ 个数有关。 其中一种取值是固定的，另一种在枚举长度时可以递推求得。 然后在 $AB$ 中选择一个 $A$ 就是选择一个前缀，这个前缀出现奇数次字母的个数比 $C$ 出现奇数次字母的个数少。 这个用 bit 维护就可以了，这样是 nlog26。 进一步分析发现，$C$ 另一种取值每次变化量最多为 1，因此就不需要bit，只需要根据他这一次的变化计算贡献。把前面的结果加以利用。 B.work每个人有四个参数，求解决na个A和nb个B的最小时间。 做法对第 $i$ 个人，考虑预处理 $cost(x,y)$ 表示解决 $x$ 个 $A$ 和 $y$ 个 $B$ 的最小代价。 这一部分是 $O(nm^3)$ 的。 然后如果是 $dp(i,x,y)$ 表示前 $i$ 个人解决 $x$ 个 $A$ 和 $y$ 个 $B$，转移枚举 $i$ 选几个 $A$ 几个 $B$，是 $O(nm^4)$。可以获得80分。 考虑优化。 由于答案是所有人的 max，可以考虑二分。 $dp(i,j)$ 表示 $i$ 个人在限制内解决 $j$ 个 $A$ 最多选的 $B$ 的个数。 然后这样发现是不对的。 因为 $cost(x,y)$ 并不是单调的。但是单谷的。 考虑证明。在 $x$ 固定的时候 $y$ 增加使得答案更小，说明把 $B$ 插入 $A$，且为独立的一段。 然后 $B$ 能有效插入的次数显然是有限的。不能插了以后都不能插。 所以 $dp(i,j)$ 应该存一个区间。 判 $nb$ 是否在区间内。 C.sort题意自己看吧。 做法观察到这个 $cnt$ 每次增加的时候会增加一个 $length(A)$。 数形结合，对长度为length(A)的序列 bubble_sort，统计答案，实际上相当于把这个贡献均摊到每个点上。 于是考虑对每个点分别计算贡献。 这个点会连续被排序直到前后两个位置都成为分界线。 于是计算每个位置成为分界线的时间。 冒泡排序是稳定排序，所以Ai相不相同并不重要，可以全部当成不同的做，用双关键字。 然后要把所有 &lt;x 的放到前面去。 考虑冒泡排序的本质，就是分为若干段，每一段进行一个循环左移。 这个线一定会被包含在某一段中，然后一段结束的位置由于已经是分界线，不存在应该往前的，所以发现所有应该往前放的都会往前一位。而且这一段的开头一定不会是应该放在前面的。若是应该放在前面的，则一整段都是，又根据分界线，前面也都是，个数就不对了。 每个点最开始一定会被排一下，所以要和1取个max。 D.magic题意自己看。 做法先考虑暴力，$a+\\frac x y=\\frac {ay+x} {y}$，然后结合的时候可能还要倒过来。 $x$ 和 $y$ 互质，所以那个 $ay+x$ 和 $y$ 也互质。 所以就不用考虑约分，直接模意义下也可以做。 然后你发现把分子分母上矩阵，就可以做了。 我把线段树维护卡了，直接前缀和，处理矩阵的逆元。 THE END","link":"/2023/01/06/2022-7-15%E6%A8%A1%E6%8B%9F%E8%B5%9B%E8%AE%B0/"},{"title":"Codeforces Hello 2023 比赛笔记","text":"vp 的，做出来 ABCDF。 A. Hall of Fame题意给定一个由 L 和 R 组成的字符串。每个 L 可以覆盖它左边（不包括它自己）的所有位置，每个 R 可以覆盖它右边（不包括它自己）的所有位置。你可以交换相邻两个字符最多一次，要使所有位置都被覆盖。无解输出 $-1$，如果不需要交换输出 $0$，否则输出交换的左边一个的下标。 题解如果没有连续的两个字符为 RL，即所有的 L 都在 R 的左边，那么最右边的 L 和最左边的 R 两个位置都无法被覆盖到。而如果有连续的两个字符为 RL，那么所有位置都能被覆盖到。 先判断如果全是 L 或全是 R 则无解。如果已经存在 RL 则输出 $0$，否则找到一个 LR 然后交换这两个即可。 Code12345678910111213141516171819202122int n;string s;int f1, f2;void solve() { cin &gt;&gt; n &gt;&gt; s; f1 = f2 = 0; rep(i, n) { if (s[i] == 'L')f1 = 1; else f2 = 1; } if (f1 + f2 != 2)cout &lt;&lt; -1 &lt;&lt; endl; else { rep(i, n - 1)if (s[i] == 'R' &amp;&amp; s[i + 1] == 'L') { cout &lt;&lt; 0 &lt;&lt; endl; return; } rep(i, n - 1)if (s[i] == 'L' &amp;&amp; s[i + 1] == 'R') { cout &lt;&lt; i + 1 &lt;&lt; endl; return; } }} B. MKnez’s ConstructiveForces Task题意给定 $n$，构造一个数组 $s$，满足 $s_i\\not =0,s_i\\in [-5000,5000]$ 且 $s_i+s_{i+1}=\\sum_{k=1}^n s_k$。 $n\\le 1000$ 题解显然 $s_i=s_{i+2}$。 如果 $n$ 为偶数，则 $s={1,-1,1,-1,1,-1,\\dots}$ 即可满足要求。 如果 $n$ 为奇数，设 $s_1=s_3=s_5=\\dots=x,s_2=s_4=s_6=\\dots=y$，则可得： $$x+y=(x+y)\\cdot\\dfrac{n-1}{2}+x$$考虑到 $x,y$ 有上下界限制，可以让 $x+y=1$，此时可以得到 $x=1-\\dfrac{n-1}{2},y=\\dfrac{n-1}{2}$。注意当 $n=3$ 时，算出来 $x=0$，无解。需要特判一下。 Code1234567891011121314151617int n;void solve() { cin &gt;&gt; n; if (n == 3) { cout &lt;&lt; &quot;NO\\n&quot;; return; } cout &lt;&lt; &quot;YES\\n&quot;; if (n % 2 == 0) { rep(i, n / 2)cout &lt;&lt; &quot;1 -1 &quot;; cout &lt;&lt; endl; } else { rep(i, n / 2)cout &lt;&lt; -1 * (n / 2 - 1) &lt;&lt; ' ' &lt;&lt; n / 2 &lt;&lt; ' '; cout &lt;&lt; -1 * (n / 2 - 1) &lt;&lt; endl; }} C. Least Prefix Sum题意给定一个长度为 $n$ 的数组 $a$，和一个数 $m$，每次可以花 $1$ 代价把一个数 $\\times -1$，求最少要多少代价使得对于每个 $k\\in[1,n]$：$$\\sum\\limits_{i=1}^k a_i\\ge \\sum\\limits_{i=1}^m a_i$$$n\\le 2\\cdot 10^5$ 题解先考虑 $k&lt;m$ 的情况。 如果 $\\sum_{i=1}^k a_i&lt; \\sum_{i=1}^m a_i$，说明需要调整，而且一定是将 $k&lt;i\\le m$ 且 $a_i&gt;0$ 的 $a_i\\times -1$，才能使不等式的右式值变小。我们肯定是希望改变的 $a_i$ 越大越好。 所以我们把下标从 $m-1$ 扫到 $1$，同时用 priority_queue 维护还没有调整过的 $a_i$。如果遇到需要调整的，就从 pq 中取出一个最大值，同时 ans++。（这个思路类似 CF3D Least Cost Bracket Sequence） $k&gt;m$ 的情况类似，就是把正负反一下。 Code1234567891011121314151617181920212223242526272829303132333435ll n, m, a[200005], cnt, ans;ll pre[200005];priority_queue&lt;ll&gt;pq;void solve() { cin &gt;&gt; n &gt;&gt; m; m--; ans = cnt = 0; while (!pq.empty())pq.pop(); rep(i, n) { cin &gt;&gt; a[i]; cnt += a[i]; pre[i] = cnt; } if (a[m] &gt; 0)pq.push(a[m] * 2); for (int i = m - 1;i &gt;= 0;i--) { while (pre[i] &lt; pre[m]) { ans++; pre[m] -= pq.top(); pq.pop(); } if (a[i] &gt; 0)pq.push(a[i] * 2); } cnt = 0; while (!pq.empty())pq.pop(); forr(i, m + 1, n - 1) { cnt += a[i]; if (a[i] &lt; 0)pq.push(a[i] * -2); while (cnt &lt; 0) { ans++; cnt += pq.top(); pq.pop(); } } cout &lt;&lt; ans &lt;&lt; endl;} D. Boris and His Amazing Haircut题意给定长度为 $n$ 的数组 $a,b$，你的目标是将 $a$ 变成 $b$。 你有 $m$ 种操作，每种有一个参数 $x$。你可以选择一个区间 $[l,r]$，然后对于每个 $i\\in [l,r],a_i:=\\min(a_i,x)$。每种操作只能使用一次。可能有多种操作的参数一样。 询问可行性。 $n,m \\le 2\\cdot 10^5,a_i,b_i,c_i \\le 10^9$ 题解首先判断：如果有 $a_i&lt;b_i$ 则无解。 可以发现，对 $i$ 使用一个 $x&gt;b_i$ 的操作是没有影响的。所以我们按照 $b_i$ 从小到大来处理。设现在处理到 $v$，那么所有 $b_i\\le v$ 的位置都可以使用操作。这些位置形成了一些极长的段，我们数出有多少段包含需要改变的位置（$b_i=v$ 且 $a_i\\not=b_i$），如果数量大于参数为 $v$ 的操作数量则无解。 可以用并查集维护每个位置在哪一段。最开始我的写法是：每处理过一个位置 $i$，则把 $i-1,i,i+1$ 所在的段都合并到一起。这样会被类似 2,1,3,1,2 的数据卡掉（然而 WA#72，不得不说数据真水）。正确的做法是在处理 $i$ 前判断 $i-1,i+1$ 是否已经处理过了，处理过就合并。 同时还要判断是否有 $i$ 使得 $a_i\\not= b_i$ 且不存在一个操作的参数 $=b_i$，这样也是无解的。我的实现是对于每个处理过的位置打上标记，最后看有没有位置没有标记。 要离散化。注意数组开大几倍。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int N = 2000006;int n, m, a[N], b[N], x[N];vector&lt;int&gt;v;int siz;int fa[N];int getf(int i) { if (fa[i] == i)return i; return fa[i] = getf(fa[i]);}vector&lt;vector&lt;int&gt;&gt;p;int cnt[N];set&lt;int&gt;s;bool vis[N];void solve() { v.clear(); cin &gt;&gt; n; rep(i, n)cin &gt;&gt; a[i], v.pb(a[i]); rep(i, n)cin &gt;&gt; b[i], v.pb(b[i]); cin &gt;&gt; m; rep(i, m)cin &gt;&gt; x[i], v.pb(x[i]); sort(v.begin(), v.end()); siz = unique(v.begin(), v.end()) - v.begin(); rep(i, n)a[i] = lower_bound(v.begin(), v.begin() + siz, a[i]) - v.begin(); rep(i, n)b[i] = lower_bound(v.begin(), v.begin() + siz, b[i]) - v.begin(); rep(i, m)x[i] = lower_bound(v.begin(), v.begin() + siz, x[i]) - v.begin(); rep(i, n)if (a[i] &lt; b[i]) { cout &lt;&lt; &quot;NO\\n&quot;; return; } rep(i, n)fa[i] = i; p.resize(siz); rep(i, siz)p[i].clear(), cnt[i] = 0; rep(i, n)p[b[i]].pb(i); rep(i, m)cnt[x[i]]++; rep(i, n)vis[i] = 0; rep(i, n - 1)if (b[i] == b[i + 1])fa[getf(i)] = getf(i + 1); rep(i, siz) { for (int j : p[i]) { if (j &amp;&amp; b[j - 1] &lt; b[j])fa[getf(j - 1)] = getf(j); if (j &lt; n - 1 &amp;&amp; b[j + 1] &lt; b[j])fa[getf(j)] = getf(j + 1); } s.clear(); for (int j : p[i])if (a[j] != b[j])s.insert(getf(j)); if (cnt[i] &lt; s.size()) { cout &lt;&lt; &quot;NO\\n&quot;; return; } for (int j : p[i])vis[j] = 1; } rep(i, n)if (!vis[i]) { cout &lt;&lt; &quot;NO\\n&quot;; return; } cout &lt;&lt; &quot;YES\\n&quot;;} E. Anya’s Simultaneous Exhibition题意交互题。 有 $n$ 个人，两两之间有胜负关系。定义一个 tourment 为：$n-1$ 场淘汰赛，最后一个人胜出。称一个人为 candidate master 当且仅当合适安排赛程后他能在 tourment 中胜出。 你可以进行至多 $2n$ 场模拟。在每场模拟中，你可以让一个人依次对战另外一些人。交互库会返回他赢的次数。请你最后输出有多少人可以成为 candidate master。 $n\\le 250$ 题解结论题，赛时没做出来。 以后补。 F. Xorcerer’s Stones题意给定一个树，节点 $i$ 权值为 $a_i$。你可以执行至多 $2n$ 次操作，每次操作可以将一个子树内所有点变成它们的异或和。求一种可行方案使得所有数变成 $0$。无解输出 $-1$。 $n\\le 2\\cdot 10^5,0\\le a_i \\le 31$ 题解可以发现，如果对大小为奇数的子树执行操作，所有权值的异或和不变；如果对大小为偶数的子树执行操作，则子树内异或和变为 $0$。而当我们将整棵树的异或和变为 $0$ 后，只需要再对整棵树进行一次操作即可全部清零。 设 $f_{i,j}=0/1$ 表示能否使以 $i$ 为根的子树内异或和为 $j$。从子节点转移上来即可。如果以 $i$ 为根的子树大小为偶数，则 $f_{i,0}=1$ ，即对这棵树执行一次操作。 恶心的是居然要输出方案！写个路径还原，同时如果是执行操作的地方要打上标记。 这样做好像只要 $n$ 次操作？ 时间复杂度 $O(nw^2)$，其中 $w=32$。$2\\cdot 10^5 \\times 32^2\\approx 2\\cdot 10^8$。给了 4s，能过。 Code赛时写的代码操作次数有点多。这里放下优化后的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const int N = 200005;int n, a[N], fa, son[N], siz[N];vector&lt;int&gt;g[N];vector&lt;int&gt;dp[N][32];void dfs(int x) { rep(i, 32)rep(j, son[x] + 1)dp[x][i][j] = -1; dp[x][a[x]][0] = 0; siz[x] = 1; rep(i, son[x]) { int y = g[x][i]; dfs(y); siz[x] += siz[y]; rep(m1, 32)rep(m2, 32) { if (dp[x][m1][i] != -1 &amp;&amp; dp[y][m2][son[y]] != -1) { dp[x][m1 ^ m2][i + 1] = m2; } } } if (siz[x] % 2 == 0)dp[x][0][son[x]] = -2;}vector&lt;int&gt;ans;void getans(int x, int val) { if (dp[x][val][son[x]] == -2) { ans.pb(x + 1); return; } for (int i = son[x] - 1;i &gt;= 0;i--) { int y = g[x][i]; getans(y, dp[x][val][i + 1]); val ^= dp[x][val][i + 1]; }}void solve() { cin &gt;&gt; n; rep(i, n)cin &gt;&gt; a[i]; rep(i, n - 1) cin &gt;&gt; fa, fa--, son[fa]++, g[fa].pb(i + 1); rep(i, n)rep(j, 32)dp[i][j].resize(son[i] + 1); dfs(0); if (dp[0][0][son[0]] == -1)cout &lt;&lt; -1; else { getans(0, 0); ans.pb(1); cout &lt;&lt; ans.size() &lt;&lt; endl; for (int x : ans)cout &lt;&lt; x &lt;&lt; ' '; }}","link":"/2023/01/08/Codeforces-Hello-2023-%E6%AF%94%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"title":"CF1680F Lenient Vertex Cover","text":"题目传送门 DFS 树的性质。 首先注意到题面中的这一句话： 最多只能有一条边，满足两个顶点都在这个点集中。 显然，“最多只能有一条边”意思就是有 $0$ 条或 $1$ 条。 0 条所以每条边都恰好只有一个顶点在点集中。 很自然想到二分图染色，每条边两个顶点颜色不同。 所以只要这个图是二分图，就一定有解。 1 条有一条边的两个点同色，那么去掉这个边后，剩下的图一定就是一个二分图，就转化成了上一个情况。 先 DFS 一遍。一个显然的重要的性质是：对于原图中的每条边，要么是 DFS 树中的一条边，要么是一条返祖边（即一个点连向它祖先的边）。 因为二分图中没有奇环，所以这条去掉的边一定在所有奇环上，而不能在任何一个偶环上（这样去掉之后就全是偶环了）。 考虑去掉什么边。 返祖边因为一个环在 DFS 树中一定是一条链加上一条返祖边，所以在 DFS 遇到返祖边时判断这个环是奇环还是偶环，就能统计出奇环数量了。如果奇环数量为 $1$，那么直接去掉那条返祖边即可。 树边在统计环时把环上的所有树边都标记 $+1$，最后看是否有一个树边满足： 所在的奇环数 $=$ 奇环总数 所在的偶环数 $=0$ 即可。 标记时用树上差分即可，不会的同学可以左转 OI Wiki。 最后判断答案时只需要再 DFS 一遍，按照深度奇偶性染色即可。 注意：有可能结果是：一条边满足两个顶点都不在点集中，其他每条边都有一个顶点在点集中。这时候只需要把所有颜色反转即可。 Code","link":"/2023/01/06/CF1680F-Lenient-Vertex-Cover/"},{"title":"FFT字符串匹配","text":"用 FFT 解决（带通配符的）字符串匹配。 前置芝士 多项式基础 卷积 FFT 不会的左转 OI Wiki。 一些基础的数学常识 完全平方公式 不会的去翻数学书。 正题普通字符串匹配设 $S$ 为模式串，$T$ 为文本串，$n=\\lvert S \\rvert,m=\\lvert T \\rvert$（字符串下标从 $0$ 开始）。 显然，两个字符串相同，当且仅当它们每一位都相同，这是一句废话。 我们联想到初中一年级的一句重要的话：**如果若干个非负数的和为 $0$，那么它们都为 $0$**。 和为 $0$ 正好对应了 每一位都相同，所以很容易得出这个 完全匹配函数（很重要！之后要考） $$f(x)=\\sum\\limits_{i=0}^{n-1} (S_i-T_{x-n+i+1})^2$$ $f(x)$ 表示 $S$ 与 $T_{(x-n+1)\\dots x}$ 的 匹配值 。 其中平方是为了保证每一项都是非负数。这样，只有每一项都为 $0$（即 $S_i=T_{x+i-1}$），$f(x)$ 才会为 $0$。 显然这个柿子不是很好化简，所以我们要对它进行一点点的变形。 什么柿子容易计算呢？当然是卷积，即： $$f(x)=\\sum\\limits_{i+j=x} A_iB_j$$ 然而之前那个柿子中，$i$ 和 $x-n+i+1$ 加起来显然不是一个定值。如何把这个 $i$ 消掉呢？ 我们考虑把 $S$ 整个串反转，这样原来的 $i$ 就变成了 $n-i-1$。 于是变成： $$f(x)=\\sum\\limits_{i=0}^{n-1} (S_{n-i+1}-T_{x-n+i+1})^2$$ 两个下标相加： $$(n-i+1)+(x-n+i+1)=x$$ 好耶！消掉了！ 于是那个柿子就可以写成： $$f(x)=\\sum\\limits_{i+j=x}(S_i-T_j)^2$$ 用完全平方公式拆开： $$f(x)=\\sum\\limits_{i+j=x}S_i^2-2S_iT_j+T_j^2$$ 显然第一项和第三项可以预处理得到，第二项就是 $S\\cdot T$ 中 $x$ 次项的系数乘上 $-2$，只需要把 $S$ 和 $T$ 看成多项式，FFT 相乘即可。 复杂度 $O(n \\log n)$。 还没有 KMP 快？别急，看接下来的。 带通配符的字符串匹配通配符，即可以匹配任意字符的字符（当然也可以匹配通配符）。 显然这种问题 KMP 就无能为力了。然而，对于 FFT 做法，我们仍然可以用相似的思路解决。 我们发现，原来 完全匹配函数 为 $0$，当且仅当对应的两个字符相同。但是，现在有了通配符，条件应该改为满足以下两个中任意一个： 对应两个字符相同 对应两个字符中有任意一个是通配符 很容易想到设通配符为 $0$（当然其它任何字符都不能为 $0$）。完全匹配函数 就变成了： $$f(x)=\\sum\\limits_{i=0}^{n-1} (S_i-T_{x-n+i+1})^2 \\cdot S_iT_j$$ 如果 $S_i=0$ 或 $T_i=0$，那么 $f(x)$ 仍然为 $0$。 老规矩，反转 $S$： $$f(x)=\\sum\\limits_{i=0}^{n-1} (S_{n-i+1}-T_{x-n+i+1})^2 \\cdot S_iT_j$$ 化成卷积形式： $$f(x)=\\sum\\limits_{i+j=x}(S_i-T_j)^2 \\cdot S_iT_j$$ 完全平方公式： $$f(x)=\\sum\\limits_{i+j=x}S_i^3T_j-2S_i^2T_j^2+S_iT_j^3$$ 看起来很复杂？但每一项还是卷积的形式，于是就用很多次 FFT 解决了。 复杂度 $O(n \\log n)$。 例题模板题残缺的字符串 Luogu 传送门 黑暗爆炸OJ 传送门 做法就是模板题，按上面方法做就完了。 注意数组大小好好算，$eps$ 我取的 $1$ 过了。 常数有点大，吸氧能过。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* Code by FGgirl *//* ♥ Fantasyn &amp; Dormiveglia ♥ */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i,a,n) for(int i=a;i&lt;=n;i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 1100006const double pi = acos(-1);int T_, case_;int n1, n2, n = 1, len = 0;string s, t;int S[MAXN], T[MAXN];struct Complex { double r, i; Complex() { r = i = 0; } Complex(double r_, double i_) :r(r_), i(i_) {}; Complex operator+(const Complex&amp; x)const { return Complex(r + x.r, i + x.i); }; Complex operator-(const Complex&amp; x)const { return Complex(r - x.r, i - x.i); }; Complex operator*(const Complex&amp; x)const { return Complex(r * x.r - i * x.i, i * x.r + r * x.i); };};int rev[MAXN];void FFT(Complex* a, int f) { rep(i, n)if (i &lt; rev[i])swap(a[i], a[rev[i]]); repp(d, log2(n)) { int l = 1 &lt;&lt; d; Complex wn = Complex(cos(2.0 * pi / l), f * sin(2.0 * pi / l)); for (int i = 0;i &lt; n;i += l) { Complex w = Complex(1, 0); rep(j, l / 2) { Complex t = w * a[i + j + l / 2], u = a[i + j]; a[i + j] = u + t; a[i + j + l / 2] = u - t; w = w * wn; } } } if (f == -1)rep(i, n)a[i].r /= n;}Complex a[MAXN], b[MAXN], ans[MAXN];vector&lt;int&gt;v;void solve() { cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; s &gt;&gt; t; reverse(s.begin(), s.end()); while (n &lt; n1 + n2)n *= 2, len++; rep(i, n)rev[i] = (rev[i / 2] / 2 | ((i &amp; 1) &lt;&lt; (len - 1))); rep(i, n1)S[i] = (isalpha(s[i]) ? s[i] - 'a' + 1 : 0); rep(i, n2)T[i] = (isalpha(t[i]) ? t[i] - 'a' + 1 : 0); rep(i, n)a[i] = Complex(S[i] * S[i] * S[i], 0), b[i] = Complex(T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = a[i] * b[i]; rep(i, n)a[i] = Complex(S[i] * S[i], 0), b[i] = Complex(T[i] * T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = ans[i] - Complex(2, 0) * a[i] * b[i]; rep(i, n)a[i] = Complex(S[i], 0), b[i] = Complex(T[i] * T[i] * T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = ans[i] + a[i] * b[i]; FFT(ans, -1); forr(i, n1 - 1, n2 - 1)if (fabs(ans[i].r) &lt;= 1)v.pb(i - n1 + 2); if (v.empty()) { cout &lt;&lt; 0; return; } cout &lt;&lt; v.size() &lt;&lt; endl; rep(i, v.size())cout &lt;&lt; v[i] &lt;&lt; ' ';}int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} 练习题CF528D Fuzzy Search Luogu 传送门 Codeforces 传送门 题目大意有两个字符串 $S,T$，长度分别为 $n,m$，字符集为 ${A,C,G,T}$，和一个整数 $k$。 我们称 $S$ 在 $T$ 的第 $i$ 位出现了，当且仅当把 $S$ 的首字符和 $T$ 的第 $i$ 个字符对齐后，$S$ 中的每一个字符能够在 $T$ 中找到一个位置偏差不超过 $k$ 的相同字符。 即对于所有的 $j \\in[1,n]$，都存在一个 $p \\in [1,m]$ 使得 $|(i+j-1)-p| \\leq k$ 且 $S_p=T_j$ 。 请求出 $S$ 在 $T$ 中出现的次数。 做法首先把四种字母分开来考虑，最后取四个集合的交即可。 接下来假设只考虑字母 A，其余三个同理。 先把 $S$ 和 $T$ 除了 A 的部分都去掉（即空白），其余位置涂色。 接下来对 $T$ 处理：由于 $T$ 中的一个 A（假设在第 $i$ 位）可以影响到 $[i-k,i+k]$ 这些位置，所以把这些位置全都涂色。 接下来直接匹配即可。对于 $S$ 上有颜色的位置，$T$ 对应位置一定要有颜色；而对于 $S$ 上空白的位置，$T$ 对应位置可以有颜色，也可以是空白。 于是把 $T$ 的涂色部分看成 $1$，空白部分看成 $2$，$S$ 的涂色部分看成 $1$，空白部分看成 $0$（即通配符）。 复杂度 $O(n \\log n)$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* Code by FGgirl *//* ♥ Fantasyn &amp; Dormiveglia ♥ */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i,a,n) for(int i=a;i&lt;=n;i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 1100006const double pi = acos(-1);int T_, case_;int n1, n2, n = 1, len = 0, k;string s, t;int S[MAXN], T[MAXN];struct Complex { double r, i; Complex() { r = i = 0; } Complex(double r_, double i_) :r(r_), i(i_) {}; Complex operator+(const Complex&amp; x)const { return Complex(r + x.r, i + x.i); }; Complex operator-(const Complex&amp; x)const { return Complex(r - x.r, i - x.i); }; Complex operator*(const Complex&amp; x)const { return Complex(r * x.r - i * x.i, i * x.r + r * x.i); };};int rev[MAXN];void FFT(Complex* a, int f) { rep(i, n)if (i &lt; rev[i])swap(a[i], a[rev[i]]); repp(d, log2(n)) { int l = 1 &lt;&lt; d; Complex wn = Complex(cos(2.0 * pi / l), f * sin(2.0 * pi / l)); for (int i = 0;i &lt; n;i += l) { Complex w = Complex(1, 0); rep(j, l / 2) { Complex t = w * a[i + j + l / 2], u = a[i + j]; a[i + j] = u + t; a[i + j + l / 2] = u - t; w = w * wn; } } } if (f == -1)rep(i, n)a[i].r /= n;}Complex a[MAXN], b[MAXN], ans[MAXN];char C[] = { 'A','C','G','T' };int d;int sum[MAXN], SUM = 0;void solve() { cin &gt;&gt; n2 &gt;&gt; n1 &gt;&gt; k &gt;&gt; t &gt;&gt; s; reverse(s.begin(), s.end()); while (n &lt; n1 + n2)n *= 2, len++; rep(i, n)rev[i] = (rev[i / 2] / 2 | ((i &amp; 1) &lt;&lt; (len - 1))); rep(c, 4) { rep(i, n1)S[i] = (s[i] == C[c]); d = 0; rep(i, min(k, n2))d += (t[i] == C[c]); rep(i, n2) { if (i + k &lt; n2)d += (t[i + k] == C[c]); T[i] = (d &gt; 0 ? 1 : 2); if (i - k &gt;= 0)d -= (t[i - k] == C[c]); } rep(i, n)a[i] = Complex(S[i] * S[i] * S[i], 0), b[i] = Complex(T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = a[i] * b[i]; rep(i, n)a[i] = Complex(S[i] * S[i], 0), b[i] = Complex(T[i] * T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = ans[i] - Complex(2, 0) * a[i] * b[i]; rep(i, n)a[i] = Complex(S[i], 0), b[i] = Complex(T[i] * T[i] * T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = ans[i] + a[i] * b[i]; FFT(ans, -1); forr(i, n1 - 1, n2 - 1)if (fabs(ans[i].r) &lt;= 1)sum[i - n1 + 1]++; } rep(i, n2 - n1 + 1)if (sum[i] == 4)SUM++; cout &lt;&lt; SUM;}int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;}","link":"/2023/01/06/FFT%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"title":"POJ1874 Trade on Verweggistan","text":"题目传送门 本题最大难点：读题。 首先说一下题意： 有 $w$ 堆货物，第 $i$ 堆有 $b_i$ 个，从上往下给定每个货物的进价。所有货物的售价都是 $10$，但是如果想买一件货物，必须要先买在它上面的所有货物。求出最大利润，以及要达成这个利润，需要买多少个货物，可能有多种方案，从小到大输出。如果超过 $10$ 个只需要输出最小的 $10$ 个。 显然先把每堆的前缀和从大到小排序，最大利润就是每堆 rk1 的前缀和加起来。 比较烦的是有的堆前缀和可能 $\\le 0$。 这里有个小 trick：每堆在排序时加一个元素 $(0,0)$，表示前 $0$ 个的利润和是 $0$。这样就可以挤掉 $\\le 0$ 的情况。 接下来处理货物数。 最小就是每堆 rk1 的长度的和，贪心计算出接下来最小的方案是什么：遍历一遍现有的所有方案，算出所有拓展的方式取 min，然后把这种方案加到答案队伍里。要去重。已经有 $10$ 个不重复的就 break。 注意： $b$ 有可能是 $0$ 输出格式，每组数据之间要空一行 实在不行去 udebug 上找组数据测测 我承认我加了 IO 优化才过。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt;v;int rk[20000][55];void solve() { v.resize(n); cnt = 0; rep(i, n) { cin &gt;&gt; m; sum = 0; v[i].clear(); v[i].pb(mp(0, 0)); rep(j, m) { cin &gt;&gt; a; sum += 10 - a; v[i].pb(mp(-sum, j + 1)); } sort(v[i].begin(), v[i].end()); } sum = 0; rep(i, n)sum -= v[i][0].fi; ans = 1; cnt = 1; init(rk[0], 0); rep(i, n) rk[0][n] += v[i][0].se; rep(I, 10000) { int mn = MAXN, id1, id2; rep(i, ans) { rep(j, n) { if (rk[i][j] &lt; 0 || rk[i][j] &gt;= (int)v[j].size() - 1 || v[j][rk[i][j] + 1].fi != v[j][rk[i][j]].fi)continue; if (rk[i][n] + v[j][rk[i][j] + 1].se - v[j][rk[i][j]].se &lt; mn) { mn = rk[i][n] + v[j][rk[i][j] + 1].se - v[j][rk[i][j]].se; id1 = i; id2 = j; } } } if (mn == MAXN)break; rep(i, n)rk[ans][i] = rk[id1][i]; rk[ans][id2]++; rk[id1][id2] = -1; rk[ans][n] = mn; if (rk[ans][n] != rk[ans - 1][n])cnt++; ans++; if (cnt == 10)break; } cout &lt;&lt; &quot;Workyards &quot; &lt;&lt; T_ &lt;&lt; endl; cout &lt;&lt; &quot;Maximum profit is &quot; &lt;&lt; sum &lt;&lt; &quot;.\\n&quot;; cout &lt;&lt; &quot;Number of pruls to buy:&quot;; rep(i, ans)if (!i || rk[i][n] != rk[i - 1][n])cout &lt;&lt; ' ' &lt;&lt; rk[i][n]; cout &lt;&lt; endl;}int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); T_ = 1; while (cin &gt;&gt; n) { if (!n)break; if (T_ &gt; 1)cout &lt;&lt; endl; solve(); T_++; } return 0;} 另一种也许可行的办法 爆搜出所有方案，放到 set 里去找到前十。上次 CSP-J 被 set 坑到 TLE ，就没敢用。","link":"/2023/01/06/POJ1874-Trade-on-Verweggistan/"},{"title":"URAL1095 Nikifor 3","text":"题目传送门 打表找规律。 首先你得先打个表，就像这样： 123456int a[] = { 1,2,3,4 };do { int x = 0; rep(i, 4) cout &lt;&lt; a[i], x = x * 10 + a[i]; cout &lt;&lt; ' ' &lt;&lt; x % 7 &lt;&lt; endl;} while (next_permutation(a, a + 4)); 然后你就能惊讶地发现，对于每个 $i\\in [1,7]$，都有至少一个 $1,2,3,4$ 的排列满足：$(组成的四位数)\\equiv i\\pmod i$。 所以考虑先在字符串中去掉 $1,2,3,4$，将剩余的所有数字放在最后面，并处理出这串数 $\\bmod 7$ 是多少，然后把 $1,2,3,4$ 按照某种顺序放在最前面就行了。 之所以要把剩余部分放在最后面而不是最前面的原因是，如果有这样一组数据：001234，就会出现前导零。 Code 12345678910111213141516171819202122232425262728293031323334353637int T_, case_;int A[7][4], sum, p;string s, t;bool f[5];void solve() { sum = 0; init(f, 0); cin &gt;&gt; s; t = &quot;&quot;; p = 1; rep(i, s.size()) { int x = s[i] - '0'; if (x &gt;= 1 &amp;&amp; x &lt;= 4 &amp;&amp; !f[x])f[x] = 1; else { t += s[i]; p = p * 10 % 7; sum = (sum * 10 + x) % 7; } } rep(i, 7)if ((i * p + sum) % 7 == 0) { rep(j, 4)cout &lt;&lt; A[i][j]; cout &lt;&lt; t &lt;&lt; endl; }}int main() { init(A, -1); int a[] = { 1,2,3,4 }; do { int x = 0; rep(i, 4) x = x * 10 + a[i]; if (A[x % 7][0] == -1)rep(i, 4)A[x % 7][i] = a[i]; } while (next_permutation(a, a + 4)); T_ = 1; cin &gt;&gt; T_; for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;}","link":"/2023/01/06/URAL1095-Nikifor-3/"},{"title":"UVA1063 Marble Game","text":"题目传送门 说是题解其实是 debug 记（叹气） 显然 BFS，状态我是用 vector&lt;vector&lt;int&gt;&gt; 来存每个格子上的 Marble 编号，洞可以根据这个推出来，就不用存。 转移时，枚举向四个方向移动。这里写四个函数可能会比较烦，我的做法是，对于 $n\\in [0,4]$，先将盘面顺时针转 $n\\cdot 90^\\circ$，再将所有 Marble 向左移动，最后将盘面顺时针旋转 $(4-n)\\cdot 90^\\circ$。 注意： 旋转时，Marble，洞和墙都要旋转。 移动时，如果 Marble 掉进了对应的洞里，就把这个 Marble 和洞都删掉，如果掉进了别人的洞里，就不进行这个方向的转移。 输出格式，impossible 首字母小写，如果答案是 1 仍然是 moves 而不是 move。 然后，我就 WA 啦。 找 gzy 的程序对拍了下，放一下生成数据的代码： 1234567891011121314151617181920212223242526272829303132333435363738int a[5][5], b[5][5], cnt;int x[16];template &lt;class T&gt;T randint(T l, T r = 0) { static mt19937 eng(time(0)); if (l &gt; r) swap(l, r); uniform_int_distribution&lt;T&gt; dis(l, r); return dis(eng);}int dx[] = { -1,0,0,1 };int dy[] = { 0,-1,1,0 };void solve() { rep(T, 1000) { rep(i, 16)x[i] = i; random_shuffle(x, x + 16); cnt = 0; rep(i, 4)rep(j, 4)a[i][j] = x[cnt++]; rep(i, 16)x[i] = i; random_shuffle(x, x + 16); cnt = 0; rep(i, 4)rep(j, 4)b[i][j] = x[cnt++]; int M = randint(1, 8), W = randint(0, 10); bool f = 0; rep(i, 4)rep(j, 4)if (a[i][j] &lt; M &amp;&amp; b[i][j] &lt; M)f = 1; if (f == 1)continue; cout &lt;&lt; 4 &lt;&lt; ' ' &lt;&lt; M &lt;&lt; ' ' &lt;&lt; W &lt;&lt; endl; rep(s, M) rep(i, 4)rep(j, 4)if (a[i][j] == s)cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; endl; rep(s, M) rep(i, 4)rep(j, 4)if (b[i][j] == s)cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; endl; while (W--) { int A = randint(1, 2), B = randint(1, 2), C = randint(0, 3); cout &lt;&lt; A &lt;&lt; ' ' &lt;&lt; B &lt;&lt; ' ' &lt;&lt; A + dx[C] &lt;&lt; ' ' &lt;&lt; B + dy[C] &lt;&lt; endl; } } cout &lt;&lt; &quot;0 0 0\\n&quot;;} 拍出来几个问题： 输入数据中下标是从 0 开始的 多测记得清空 每次移动后，Marble 和洞都要还原成移动前的位置 记录每个 Marble 是否出现的数组要开至少 8 大小 拍出来问题的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Input 14 3 70 12 00 32 11 13 22 2 3 21 2 1 31 1 2 12 1 2 22 2 3 22 2 3 21 2 1 1Output 1impossibleInput 24 8 90 01 02 03 03 13 23 32 31 22 22 11 10 10 20 31 30 0 0 11 0 1 12 0 2 12 1 3 12 2 3 22 2 2 31 2 1 30 2 1 21 1 1 2Output 225 moves Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100int n, m, w, A, B, C, D;bool operator&lt;(vector&lt;vector&lt;int&gt;&gt; A, vector&lt;vector&lt;int&gt;&gt; B) { repp(i, n)repp(j, n)if (A[i][j] != B[i][j])return A[i][j] &lt; B[i][j]; return 0;}bool operator==(vector&lt;vector&lt;int&gt;&gt; A, vector&lt;vector&lt;int&gt;&gt; B) { repp(i, n)repp(j, n)if (A[i][j] != B[i][j])return 0; return 1;}vector&lt;vector&lt;int&gt;&gt; a(5), b(5), x(5), y(5), cpy(5);bool f[5][5][5][5], f_[5][5][5][5], F[100];map&lt;vector&lt;vector&lt;int&gt;&gt;, int&gt;vis;void rotate(int N) { while (N--) { repp(i, n)repp(j, n)cpy[i][j] = x[n + 1 - j][i]; x = cpy; repp(i, n)repp(j, n)cpy[i][j] = y[n + 1 - j][i]; y = cpy; repp(i1, n)repp(j_1, n)repp(i2, n)repp(j2, n)f_[i1][j_1][i2][j2] = f[n + 1 - j_1][i1][n + 1 - j2][i2]; repp(i1, n)repp(j_1, n)repp(i2, n)repp(j2, n)f[i1][j_1][i2][j2] = f_[i1][j_1][i2][j2]; }}bool move() { repp(i, n) { repp(j, n) { if (!x[i][j])continue; int k = j; while (k &gt; 1 &amp;&amp; !f[i][k - 1][i][k] &amp;&amp; !x[i][k - 1]) { x[i][k - 1] = x[i][k]; x[i][k] = 0; k--; if (y[i][k] == x[i][k]) { x[i][k] = y[i][k] = 0; break; } if (y[i][k] &amp;&amp; y[i][k] != x[i][k])return 0; } } } return 1;}int bfs() { queue&lt;pair&lt;vector&lt;vector&lt;int&gt;&gt;, int&gt;&gt;q; q.push(mp(a, 0)); vis[a] = T_; while (!q.empty()) { x = q.front().fi; int val = q.front().se; q.pop(); init(F, 0); bool tmp = 0; repp(i, n)repp(j, n)if (x[i][j])F[x[i][j]] = tmp = 1; if (!tmp)return val; repp(i, n)repp(j, n) { if (F[b[i][j]])y[i][j] = b[i][j]; else y[i][j] = 0; } vector&lt;vector&lt;int&gt;&gt;xx = x, yy = y; bool suc; suc = move(); if (suc &amp;&amp; vis[x] != T_)q.push(mp(x, val + 1)), vis[x] = T_; x = xx, y = yy; rotate(1); suc = move(); rotate(3); if (suc &amp;&amp; vis[x] != T_)q.push(mp(x, val + 1)), vis[x] = T_; x = xx, y = yy; rotate(2); suc = move(); rotate(2); if (suc &amp;&amp; vis[x] != T_)q.push(mp(x, val + 1)), vis[x] = T_; x = xx, y = yy; rotate(3); suc = move(); rotate(1); if (suc &amp;&amp; vis[x] != T_)q.push(mp(x, val + 1)), vis[x] = T_; } return -1;}void solve() { repp(i, n)a[i].resize(5), b[i].resize(5), x[i].resize(5), y[i].resize(5), cpy[i].resize(5); repp(i, n)repp(j, n)a[i][j] = b[i][j] = 0; repp(i, n)repp(j, n)repp(ii, n)repp(jj, n)f[i][j][ii][jj] = 0; repp(i, m) { cin &gt;&gt; A &gt;&gt; B; a[A + 1][B + 1] = i; } repp(i, m) { cin &gt;&gt; A &gt;&gt; B; b[A + 1][B + 1] = i; } repp(i, w) { cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D; A++, B++, C++, D++; f[A][B][C][D] = f[C][D][A][B] = 1; } int ans = bfs(); if (ans == -1) cout &lt;&lt; &quot;Case &quot; &lt;&lt; T_ &lt;&lt; &quot;: impossible\\n\\n&quot;; else cout &lt;&lt; &quot;Case &quot; &lt;&lt; T_ &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; &quot; moves\\n\\n&quot;;}","link":"/2023/01/06/UVA1063-Marble-Game/"},{"title":"一些trick","text":"OI 中的一些不常用小技巧。 枚举子集枚举 $i$ 在二进制下的的所有子集 $j$（即 $i &amp; j=j$） 1234for(int j=i;;j=(j-1)&amp;i){ // something here if(!j)break;} 顺便说一下，$\\sum\\limits_{i=1}^{2^n}2^{\\operatorname{popcount}(i)}=O(3^n)$ splay 求 x 节点的 rk有时 val 不满足 $左&lt;根&lt;右$ 时（比如文艺平衡树），无法正常实现 rk 可以先把 x splay 至根，然后求根的左子树 siz 注意树上有标记时要先把 x 的祖先按深度从小到大顺序 pushdown tag 区间覆盖 dp每个区间转成两个端点处的差分（l+1,(r+1)-1），记录当前的前缀和 dp。","link":"/2023/01/06/%E4%B8%80%E4%BA%9Btrick/"},{"title":"我们创造的事物会改变我们自己——We become what we behold 游玩后记","text":"We become what we behold 是国外开发者 Nicky Case 开发的一款网页游戏。这边放一下链接。游戏流程很短，5分钟可以通关。 游戏的初始界面就很好地诠释了标题：电视里套着电视，里面一个电视上的内容被显示在外面一个电视上，无限递归。 点击“PLAY”后，黑色的背景上显示出来马歇尔·麦克卢汉的一句名言： 我们成为了我们看到的事物。我们创造的事物会改变我们自己。 然后进入游戏主界面，一群小人在草地上闲逛，中央摆着一台电视。可以看出来，小人分为圆圈和方块两个“种族”。刚开始，它们只是闲逛，无事发生。 同时，还有一个黑框跟随着鼠标移动，当你单击时，黑框中的图像就会被拍下来，投影到电视屏幕上，被所有人看到。当你拍下一些特定的内容时，小人们会有特定的反应。 例如，如果你把那个戴帽子的人拍下来，同时配上文字“真是一顶好看的帽子”然后发表为头条。接着，附近的一些小人都戴上了这种帽子。 而如果你再拍摄一个戴帽子的人，但这次配上的文字是“现在NVM的帽子一点都不好看了”，小人就又摘下了自己的帽子。 接下来，真正厉害的地方开始了。你拍下人群中一个疯子对着一个无辜的路人大叫的场面，并配上文字“疯狂的方块会攻击人”发表。一个看到新闻的圆圈显得忧心忡忡。 它开始畏惧方块，走路时不停地左右张望，遇到方块就害怕地躲开。这时如果你恰好拍下了这一画面，并配上“圆圈害怕方块”发表，此时一个路过的方块看见了新闻，从此对圆圈产生了偏见。 之后这个方块走在路上时，遇到了一个圆圈并对它表示不屑。这一幕被配上文字“方块冷落圆圈”放在了电视上。看到的一个圆圈此时心里已经有了对方块的仇恨。在游戏中，以身体变为红色表示。 你若还想继续煽风点火，便把这位愤怒的圆圈恐吓方块的图片，配上“圆圈憎恨方块”发表。看到新闻的圆圈和方块情绪都被感染了——它们都变成了红色。 接下来的事情就顺着思路走了。你可以再拍下更多方块和圆圈之间发生矛盾的照片，再配上引战的文字发表： 方块憎恨圆圈 几乎所有人都互相仇恨…… 所有人都互相仇恨！ 此时草地上已经遍布红色的小人了，它们四处乱跑，场面混乱不堪。直到有一个人对着一个并不愤怒的疯子举起了手枪…… 然后它开枪了，整个世界彻底陷入了疯狂。 可你还并不打算善罢甘休，继续拍下战争的场面。“恐惧吧！愤怒吧！”电视机前的小人纷纷举起了武器。 现在所有人都陷入了战争中，无一幸免，只不过有的是疯狂的攻击者，其他人是只能慌张地大叫，四处逃窜的受害者。屏幕上头条的红色和草地上的血色一样。 最后，镜头逐渐拉远，你发现玩家其实就是一个媒体工作者，在笔记本电脑前以上帝视角观察着一切，并依靠一块电视屏幕影响着世界里的人。而这个世界里的生与死，与玩家本人的存亡没有半点关系，顶多是会影响到他的视频播放量而已。 游戏到这里就结束了。 回顾整个故事，刚开始一切都平安，但玩家仅仅是拍摄一些“真实”的画面，再配上一点文字，然后放到电视屏幕上，就让这个世界发生了天翻地覆的变化：他引发了两个“种族”之间的矛盾，直接导致了战争，无数人无辜死亡…… 这就是媒体的可怕之处：断章取义地将偶然发生的事情添油加醋，大肆报道，使人们认为这偶然发生的事件是普遍现象，从而美化或丑化某样事物。如果从上帝视角来看，幕后的一切都一目了然，但屏幕前的没有分辨能力的观众却被媒体主导了思想。 记得2011年撒贝宁在演讲中说，如果未来手机能实时上传视频（直播），并且带宽足够大，那还要电视做什么？还要他这样的电视台主持人做什么？任何一个普通人，在街上看到事件，就可以立马打开手机直播，对着观众报道。 当时台下的观众都在笑，而到了今天，他的预言成为了现实。各种短视频平台，许多人争相对时下热点加以评论，甚至为了浏览量对事实加以捏造篡改。 在游戏中，如果你拍到的画面没有什么抓眼球的点，会显示“你应该拍些有意思的东西”，宛如你是一个还尚存良心的记者，而他是只想要吸引人眼球的报社，去逼迫你写下一些毫无意义与真实性的文字。 现在，电视的作用就是给观众一个权威的公证，去告诉观众：你们可以相信我。让人民起码在网上数不清的信息中能找到一个正确的。 除了媒体的工作，更重要的是群众对待新闻的态度。如果所有人都能理性地看待网上的各种新闻，知道它们不可信，那有再多的媒体消息也不用怕。但如果真有人像第一个变红的圆圈一样轻信它，其他人盲目跟风，官方的电视台有多权威也拯救不了，一旦有导火索，舆论就一发不可收拾了。 游戏中还有一个细节，当大多数人都变红的时候吗，草地上还有两个人呼吁着和平（右上角 ），还有一个疯子四处闲逛（左下角）。它们都是没有被舆论干扰的人，前者是因为理性，后者是因为根本不知道发生了什么。然而它们最终还是被浪潮一样的发怒的人吞噬了，和那些人一样变成了地上的血迹。 引用一下开头的句子作为结尾： 我们成为了我们看到的事物。我们创造的事物会改变我们自己。 互联网本来被创造出来是为了方便我们，而不是改变我们。 （最后吐槽一下，游戏里如果战争开始之后玩家不拍几张照片然后结束游戏，地上的血会越来越多，我的电脑被卡爆了）","link":"/2023/01/10/%E6%88%91%E4%BB%AC%E5%88%9B%E9%80%A0%E7%9A%84%E4%BA%8B%E7%89%A9%E4%BC%9A%E6%94%B9%E5%8F%98%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E2%80%94%E2%80%94We-become-what-we-behold-%E6%B8%B8%E7%8E%A9%E5%90%8E%E8%AE%B0/"},{"title":"斯涅尔定律最愚蠢的证法","text":"2022 年整的最后一个活。 问题平面直角坐标系上有两点 $S(0,h_1)$ 和 $T(w,h_2)$ 满足 $h_1&gt;0,h_2&lt;0$，一个动点 $P$ 从 $S$ 出发移动到 $T$。$P$ 在 $x$ 轴上方时的速度为 $v_1$，在 $x$ 轴下方时的速度为 $v_2$，求时间最短的路径。 斯涅尔定律：$\\dfrac{\\sin(\\theta_1)}{v_1}=\\dfrac{\\sin(\\theta_2)}{v_2}$ 证明显然，路径为两条线段组成的折线，转折点在 $x$ 轴上。 设折线与 $x$ 轴交点位于 $(0,x)$。 容易得出路径长度的函数 $f(x)$：$$f(x)=\\dfrac{\\sqrt{h_1^2+x^2}}{v}+\\dfrac{\\sqrt{h_2^2+(w-x)^2}}{v2}$$ 当取 $h_1=3,h_2=5,w=10,v_1=3,v_2=1$ 时，函数图像长这个样子： 发现它是一个单谷函数，它的最小值就是唯一的极小值。所以求导： $$f’(x)=\\dfrac{v_2x\\sqrt{(w-x)^2+h_2^2}-v_1(w-x)\\sqrt{x^2+h_1^2}}{v_1v_2\\sqrt{x^2+h_1^2}\\sqrt{(w-x)^2+h_2^2}}$$ 最小值点的导数为 $0$，所以得出： $$v_2x\\sqrt{(w-x)^2+h_2^2}=v_1(w-x)\\sqrt{x^2+h_1^2}$$ $$\\dfrac{x\\sqrt{(w-x)^2+h_2^2}}{(w-x)\\sqrt{x^2+h_1^2}}=\\dfrac{v_1}{v_2}$$ $$\\dfrac{x}{\\sqrt{x^2+h_1^2}}:\\dfrac{w-x}{\\sqrt{(w-x)^2+h_2^2}}=v_1:v_2$$ $$\\dfrac{SP}{SM}:\\dfrac{QT}{MT}=v_1:v_2$$ $$\\dfrac{\\sin(\\theta_1)}{v_1}=\\dfrac{\\sin(\\theta_2)}{v_2}$$ 证毕。","link":"/2023/01/06/%E6%96%AF%E6%B6%85%E5%B0%94%E5%AE%9A%E5%BE%8B%E6%9C%80%E6%84%9A%E8%A0%A2%E7%9A%84%E8%AF%81%E6%B3%95/"},{"title":"百度之星2022初赛游记","text":"做的是第二场。 看别人打的第一场做了 7 题还 100+ 名，一开题感觉一道都不会做，很慌。 最后做出来 5 题，66 名，很开心。 做题顺序：$1\\rightarrow 3 \\rightarrow 7 \\rightarrow 5 \\rightarrow 4$ 这场显然偶数题比奇数题难。 1. 和题意给定一个长为 $n$ 的序列，有 $q$ 次询问，每次询问 $[l,r]$ 区间内最大的 $k$ 个数之和是否 $\\ge x$。 $n,q \\le 10^5,k\\le 10,a_i \\le 10^4,x\\le 10^8$ 做法第一遍写了莫队，用 set 维护，显而易见 TLE 了。（不过这个我还写了好久 /lh） 由于 $k$ 十分小，所以用线段树维护区间内前 $k$ 小的值，合并什么的总之就是非常暴力。 复杂度 $O(nk \\log k+qk\\log nk)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i, n) forr(i, 0, n-1)#define repp(i, n) forr(i, 1, n)#define pb push_back#define mp make_pair#define init(a, i) memset(a, i, sizeof(a))#define fi first#define se second#define MAXN 0x3f3f3f3f#define ls node*2+1#define rs node*2+2int T_ = 1, case_;int a[100005];int n, q, k, x;int tree[400005][21], cnt[400005];void build(int node, int l, int r) { if (l == r) { cnt[node] = 1; tree[node][0] = a[l]; return; } int mid = l + r &gt;&gt; 1; build(ls, l, mid); build(rs, mid + 1, r); cnt[node] = 0; rep(i, cnt[ls])tree[node][cnt[node]++] = tree[ls][i]; rep(i, cnt[rs])tree[node][cnt[node]++] = tree[rs][i]; sort(tree[node], tree[node] + cnt[node]); reverse(tree[node], tree[node] + cnt[node]); cnt[node] = min(cnt[node], k);}vector&lt;int&gt;ans;void query(int node, int l, int r, int L, int R) { if (L &lt;= l &amp;&amp; r &lt;= R) { rep(i, cnt[node])ans.pb(tree[node][i]); return; } int mid = l + r &gt;&gt; 1; if (mid &gt;= L)query(ls, l, mid, L, R); if (mid &lt; R)query(rs, mid + 1, r, L, R);}int l, r, sum;void solve() { cin &gt;&gt; n &gt;&gt; q &gt;&gt; k &gt;&gt; x; rep(i, n)cin &gt;&gt; a[i]; build(0, 0, n - 1); while (q--) { cin &gt;&gt; l &gt;&gt; r; ans.clear(); query(0, 0, n - 1, l - 1, r - 1); sum = 0; sort(ans.begin(), ans.end()); reverse(ans.begin(), ans.end()); rep(i, min((int)ans.size(), k))sum += ans[i]; if (sum &gt;= x)cout &lt;&lt; &quot;Y\\n&quot;; else cout &lt;&lt; &quot;N\\n&quot;; }}int main() { // ios::sync_with_stdio(0); // cin.tie(0), cout.tie(0); // cin &gt;&gt; T_; for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;} 3. 逃离这棵树题意给定一棵大小为 $n$ 的树，根节点为 $1$，每个点有权重 $p_i$，$i$ 到 $j$ 的边有权重 $q_{i,j}$。 当站在点 $i$ 上时，下一步有 $\\frac{p_i}{p_i+\\sum q_{i,j}}$ 的概率留在原地，有 $\\frac{q_{i,j}}{p_i+\\sum q_{i,j}}$ 的概率到 $j$ 节点（$j$ 为 $i$ 的儿子）。 初始时在根节点，问期望多少步后到达叶节点，对 $998244353$ 取模。 $n \\le 10^6,p_i,q_{i,j}\\le 10$ 做法做法类似于某场 ABC 的 E 题，只是把数轴换成了树。然而我至今没有补掉那个题，但是赛时把这个题切了。 设 $dp_i$ 为 $i$ 期望走多少步到叶节点。 考虑枚举从 $i$ 下一步到达的点 $j$，$j$ 对 $i$ 的答案的贡献是 $\\frac{q_{i,j}}{p_i+\\sum q_{i,j}} \\cdot dp_j$。 另外，$i$ 节点期望要 $\\frac{p_i+\\sum q_{i,j}}{p_i}$ 步离开原地，所以 $dp_i$ 还要再加上这个数。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i, n) forr(i, 0, n-1)#define repp(i, n) forr(i, 1, n)#define pb push_back#define mp make_pair#define init(a, i) memset(a, i, sizeof(a))#define fi first#define se second#define MAXN 0x3f3f3f3fint T_ = 1, case_;const int MOD = 998244353;ll qpow(ll x, ll y) { ll p = 1; while (y) { if (y &amp; 1)p = p * x % MOD; x = x * x % MOD; y &gt;&gt;= 1; } return p;}ll inv(ll x) { return qpow(x, MOD - 2); }int n, p[1000006], q[1000006];vector&lt;vector&lt;int&gt;&gt;v;ll dp[1000006];void dfs(int x) { if (v[x].empty()) { dp[x] = 0; return; } ll sum = 0; for (int y : v[x]) { dfs(y); sum += q[y]; } ll INV = inv(sum); dp[x] = (sum + p[x]) * INV; for (int y : v[x])dp[x] = (dp[x] + q[y] * INV % MOD * dp[y] % MOD) % MOD;}void solve() { cin &gt;&gt; n; rep(i, n) cin &gt;&gt; p[i]; v.resize(n); repp(i, n - 1) { int a; cin &gt;&gt; a &gt;&gt; q[i]; v[a - 1].pb(i); } dfs(0); cout &lt;&lt; dp[0];}int main() { // ios::sync_with_stdio(0); // cin.tie(0), cout.tie(0); // cin &gt;&gt; T_; for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;} 4. 通信网络题意给定一个 $n$ 个点，$m$ 条边的无向图，一条边 $(u,v,w)$ 表示这条边连接 $u$ 和 $v$，长度为 $w$。有 $q$ 次询问，每次询问给定 $k$ 个关键点，第 $i$ 个关键点为 $p_i$，与这个点的距离 $\\le d_i$ 的节点会被打上标记。对于每次询问，输出有多少个点被打上了标记。询问之间独立，也就是每次打上的标记会在下一次询问前清空。 $n \\le 10^3,m \\le 10^4,q \\le 10^5,\\sum k \\le 10^6,w \\le 10^6,d_i \\le 10^9$ 做法把询问离线下来，对于每个关键点分别处理。 对于每个询问一个 bitset $ans_i$，$ans_{i,j}$ 表示在第 $i$ 次询问中，$j$ 是否被打上了标记。 对于每个关键点 $x$，把和它有关的询问按照 $d$ 从小到大排序。 维护一个 bitset $res$，$res_i$ 表示 $i$ 与 $x$ 的距离是否 $\\le d$。容易发现，由于 $d$ 已经从小到大排序过了，所以 $res$ 中的元素只会从 $0$ 变成 $1$，或者不变。 所以先跑一边 dijkstra，处理出所有点到 $x$ 的距离，然后把所有点按照与 $x$ 的距离排序，单调地往 $res$ 中加入就可以了。处理到第 $i$ 个询问时，把 $ans_i$ 按位或上 $res$，最后答案就是 $ans_i.count()$。 复杂度 $O(n^2\\log n+nm \\log m+k \\log k+\\frac{nk}{\\omega})$，能过。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i, n) forr(i, 0, n-1)#define repp(i, n) forr(i, 1, n)#define pb push_back#define mp make_pair#define init(a, i) memset(a, i, sizeof(a))#define fi first#define se second#define MAXN 0x3f3f3f3fint T_ = 1, case_;int n, m, q, a, b, c;int dist[1010];int k;vector&lt;pair&lt;int, int&gt;&gt;g[1010], v[1010];bitset&lt;1010&gt;ans[100005], tmp;priority_queue&lt;pair&lt;int, int&gt;&gt;pq;int id[1010];void solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; rep(i, m) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; a--, b--; g[a].pb(mp(b, c)); g[b].pb(mp(a, c)); } rep(i, q) { cin &gt;&gt; k; rep(j, k) { cin &gt;&gt; a &gt;&gt; b; v[a - 1].pb(mp(b, i)); } } rep(i, n) { if (v[i].empty())continue; init(dist, 63); dist[i] = 0; pq.push(mp(0, i)); while (!pq.empty()) { int val = -pq.top().fi, x = pq.top().se; pq.pop(); if (val != dist[x])continue; if (g[x].size())rep(j, g[x].size()) { int y = g[x][j].fi, w = g[x][j].se; if (dist[y] &gt; val + w) { dist[y] = val + w; pq.push(mp(-dist[y], y)); } } } tmp.reset(); rep(i, n)id[i] = i; sort(id, id + n, [&amp;](int x, int y) {return dist[x] &lt; dist[y];}); sort(v[i].begin(), v[i].end()); int p = 0; rep(j, v[i].size()) { while (p &lt; n &amp;&amp; dist[id[p]] &lt;= v[i][j].fi) { tmp[id[p]] = 1; p++; } ans[v[i][j].se] |= tmp; } } rep(i, q)cout &lt;&lt; ans[i].count() &lt;&lt; endl;}int main() { // ios::sync_with_stdio(0); // cin.tie(0), cout.tie(0); // cin &gt;&gt; T_; for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;} 5. 星球联通题意给定三维空间内的 $n$ 个点，表示一个点的坐标为 $(x,y,z)$，连接两个点的代价是它们距离的平方。 现在可以免费连接 $k$ 个点，额外再连接 $i$ 个点（即一共连接 $k+i$ 个点）需要花 $c_i$ 的代价。 求将所有点连通起来的最小代价。 $k \\le n \\le 3000,c_i \\le 10^9,x,y,z \\le 10^4$ 做法显然枚举额外连接多少个星球，现在问题变成： 给定一张带权完全图，连接其中 $x$ 个点，代价最少是多少。 容易联想到最小生成树的 Kruskal 算法。改一下： 把边按边权从小到大依次检查，如果连接的两个点不在同一个连通分量里，就把这条边加进去。当有 $x-1$ 条边时结束。 这个看上去就很对的算法实际上也是对的，正确性易证，但是我不会证，大概和 Kruskal 的证法差不多。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i, n) forr(i, 0, n-1)#define repp(i, n) forr(i, 1, n)#define pb push_back#define mp make_pair#define init(a, i) memset(a, i, sizeof(a))#define fi first#define se second#define MAXN 0x3f3f3f3f3f3f3f3fint T_ = 1, case_;ll n, k, c[3010], x[3010], y[3010], z[3010], ans, sum, cnt;vector &lt; pair&lt;ll, pair&lt;int, int&gt;&gt;&gt;v;int fa[3010];int getf(int i) { if (fa[i] == i)return i; return fa[i] = getf(fa[i]);}void solve() { cin &gt;&gt; n &gt;&gt; k; repp(i, n - k)cin &gt;&gt; c[i]; rep(i, n)cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; z[i]; rep(i, n)forr(j, i + 1, n - 1) { ll X = x[i] - x[j], Y = y[i] - y[j], Z = z[i] - z[j]; ll val = X * X + Y * Y + Z * Z; v.pb(mp(val, mp(i, j))); } sort(v.begin(), v.end()); rep(i, n)fa[i] = i; ans = c[n - k], sum = 0, cnt = n - k; rep(i, v.size()) { int a = v[i].se.fi, b = v[i].se.se; if (getf(a) == getf(b))continue; cnt--; fa[getf(a)] = getf(b); sum += v[i].fi; ans = min(ans, sum + c[cnt]); if (!cnt)break; } cout &lt;&lt; ans;}int main() { // ios::sync_with_stdio(0); // cin.tie(0), cout.tie(0); // cin &gt;&gt; T_; for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;} 7. 原地传送题意有一个 $n\\times m$ 的网格图，起点为 $(0,0)$，终点为 $(n,m)$，每次可以从 $(x,y)$ 走到 $(x+1,y)$ 或 $(x,y+1)$。 有 $k$ 个传送门，第 $i$ 个传送门在 $(x_i,y_i)$，碰到传送门就必须要立即移动到另一个传送门（不能原地传送）。 求有多少种恰好传送一次后到达终点的行走方案。 $n,m \\le 10^5,k \\le 2000$ 做法枚举传送的起点和终点是哪两个传送门，问题转化成： 有多少种方法从起点走到传送门 $i$ / 从传送门 $i$ 走到终点，中途不碰到任何其它的传送门。 考虑从起点走到传送门 $i$ 的情况，另一种同理。 设 $i$ 的答案是 $dp_i$，$cnt(a,b)$ 表示向 $x$ 方向走 $a$ 步，向 $y$ 方向走 $b$ 步的方案数。 易得 $cnt(a,b)=\\binom{a+b}{a}$。 如果不考虑 “中途不碰到任何其它的传送门” 这一条件，那么 $dp_i=cnt(x_i,y_i)$。 枚举第一个碰到的传送门 $j$，从起点走到 $j$ （中途不碰到任何其它的传送门）有 $dp_j$ 种方案，从 $j$ 走到 $i$（因为已经确定了第一个碰到的，所以后面就没有限制条件了）有 $cnt(x_i-x_j,y_i-y_j)$ 种方案，所以 $dp_i$ 要减去 $dp_j \\cdot cnt(x_i-x_j,y_i-y_j)$。 然后发现只有在 $x_j\\le x_i$ 且 $y_j \\le y_i$ 时这个转移才有效，所以把所有坐标按照 $x+y$ 从小到大排序，计算 $dp_i$ 时只要考虑所有 $j&lt;i$。 复杂度 $O(n^2)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i, n) forr(i, 0, n-1)#define repp(i, n) forr(i, 1, n)#define pb push_back#define mp make_pair#define init(a, i) memset(a, i, sizeof(a))#define fi first#define se second#define MAXN 0x3f3f3f3fint T_ = 1, case_;int n, m, r, c, a[20][20];vector&lt;int&gt;v;int cost1[20][20], cost2[20], dp[20][20], ans = MAXN;void solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; c; rep(i, n)rep(j, m)cin &gt;&gt; a[i][j]; repp(w, (1 &lt;&lt; m) - 1) { v.clear(); rep(i, m)if ((w &gt;&gt; i) &amp; 1)v.pb(i); if ((int)v.size() != c)continue; rep(i, n)forr(j, i + 1, n - 1) { cost1[i][j] = 0; rep(k, c)cost1[i][j] += abs(a[i][v[k]] - a[j][v[k]]); } rep(i, n) { cost2[i] = 0; rep(j, c - 1)cost2[i] += abs(a[i][v[j]] - a[i][v[j + 1]]); } init(dp, 63); rep(i, n) { dp[i][0] = 0, dp[i][1] = cost2[i]; forr(j, 2, i + 1)rep(k, i)dp[i][j] = min(dp[i][j], dp[k][j - 1] + cost1[k][i] + cost2[i]); ans = min(ans, dp[i][r]); } } cout &lt;&lt; ans;}int main() { // ios::sync_with_stdio(0); // cin.tie(0), cout.tie(0); // cin &gt;&gt; T_; for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;} 写在最后感觉这场比赛都是第一眼很吓人，仔细想想其实还好的题。 大家来了应该都能爆切吧。 QwQ","link":"/2023/01/06/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F2022%E5%88%9D%E8%B5%9B%E6%B8%B8%E8%AE%B0/"}],"tags":[],"categories":[{"name":"比赛笔记","slug":"比赛笔记","link":"/categories/%E6%AF%94%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"游戏","slug":"游戏","link":"/categories/%E6%B8%B8%E6%88%8F/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"}],"pages":[]}