{"posts":[{"title":"2022&#x2F;7&#x2F;15模拟赛记","text":"ych 出的模拟赛 /bx /bx /bx 原题场 /fn /fn /fn 赛时T1 string 发现是 NOIP 原题，然而忘记自己做过了。 想了一会发现自己做过，但是 ych 这个【】居然卡常，1e6-&gt;3e6 /oh 然而自己之前写的是 BIT，吸氧后 900+ms，感觉有点危险，写了个 $O(n\\ln n+n\\cdot 26)$ 的，感觉也许能过。 ych 啊 ych，既然已经加强数据范围了就不要出毒瘤数据了吧。 预估 100pts T2 work上午刚做过 P4158 粉刷匠，就只想着背包了。 然后就写了个背包，复杂度 $O(na^2nb^2n)$，感觉很危险，有可能能过。 预估 80pts T3 sort一开始瞎推推出来个 _逆序对数+递归层数_，然而这玩意居然是能过样例的。 写了个暴力对拍下，发现错了，然后白兰去看 T4 了。 最后 30min 随便想了一个结论：每个点到最后面的比它小的点的距离之和，发现能过样例，和暴力拍拍也对的 /xia 最后造了个 2000 个 1e9 的数据，发现输出 0，于是写了个特判原数组已经有序就输出 $n$。 用 BIT 实现的，复杂度 $O(n \\log n)$，1e5 的数据应该轻松。 预估 100pts T4 magic想到 mod 不能约分，直接放弃。 预估 0pts 总分预估 100+80+100+0=280pts 赛后T1 被卡 T 成 80pts，T2,3,4 发挥稳定 总分 80+80+100+0=260pts 发现 T2 正解实际上要二分，有单谷性质 /px 蓝 /bx T3 居然结论猜对了 T4 矩阵乘法，维护前缀后缀积，然而 ych 卡带 log 的线段树做法 /baojin ych 没开 O2，重测 /fn /fn /fn 吸氧后 T1 过了。 O2 /qiang 总分 100+80+100+0=280pts 以下为第二天 gzy T3 被卡后发现我的也挂了 successful hack! gzy /bx 总分 100+80+90+0=270pts T1 被 sanwei 卡成 96 分。 反正本来也过不了的。 总分 96+80+90+0=266pts sanwei /bx Links贴下原题链接吧 T1 string NOIP2020 字符串匹配 T2 work WC2001 高性能计算机 T3 sort USACO18OPEN Out of Sorts P T4 magic 「LibreOJ NOI Round #2」单枪匹马 打的太差就不贴代码了 另附 ych 写的题解，如果像我一样觉得出题人很可爱的可以不看 # 题解 A.string题意给定字符串 $S$，求把 $S$ 拆分为 $ABAB…ABC$ 这样的形式的方案数。 做法考虑枚举 $AB$ 的长度，用 $Z$ 函数求出最多连续 $AB$ 作为前缀的数量。 考虑 $C$ 中出现奇数次的字母的个数，发现对于 $AB$ 长度固定时只有两种取值，和选的 $AB$ 个数有关。 其中一种取值是固定的，另一种在枚举长度时可以递推求得。 然后在 $AB$ 中选择一个 $A$ 就是选择一个前缀，这个前缀出现奇数次字母的个数比 $C$ 出现奇数次字母的个数少。 这个用 bit 维护就可以了，这样是 nlog26。 进一步分析发现，$C$ 另一种取值每次变化量最多为 1，因此就不需要bit，只需要根据他这一次的变化计算贡献。把前面的结果加以利用。 B.work每个人有四个参数，求解决na个A和nb个B的最小时间。 做法对第 $i$ 个人，考虑预处理 $cost(x,y)$ 表示解决 $x$ 个 $A$ 和 $y$ 个 $B$ 的最小代价。 这一部分是 $O(nm^3)$ 的。 然后如果是 $dp(i,x,y)$ 表示前 $i$ 个人解决 $x$ 个 $A$ 和 $y$ 个 $B$，转移枚举 $i$ 选几个 $A$ 几个 $B$，是 $O(nm^4)$。可以获得80分。 考虑优化。 由于答案是所有人的 max，可以考虑二分。 $dp(i,j)$ 表示 $i$ 个人在限制内解决 $j$ 个 $A$ 最多选的 $B$ 的个数。 然后这样发现是不对的。 因为 $cost(x,y)$ 并不是单调的。但是单谷的。 考虑证明。在 $x$ 固定的时候 $y$ 增加使得答案更小，说明把 $B$ 插入 $A$，且为独立的一段。 然后 $B$ 能有效插入的次数显然是有限的。不能插了以后都不能插。 所以 $dp(i,j)$ 应该存一个区间。 判 $nb$ 是否在区间内。 C.sort题意自己看吧。 做法观察到这个 $cnt$ 每次增加的时候会增加一个 $length(A)$。 数形结合，对长度为length(A)的序列 bubble_sort，统计答案，实际上相当于把这个贡献均摊到每个点上。 于是考虑对每个点分别计算贡献。 这个点会连续被排序直到前后两个位置都成为分界线。 于是计算每个位置成为分界线的时间。 冒泡排序是稳定排序，所以Ai相不相同并不重要，可以全部当成不同的做，用双关键字。 然后要把所有 &lt;x 的放到前面去。 考虑冒泡排序的本质，就是分为若干段，每一段进行一个循环左移。 这个线一定会被包含在某一段中，然后一段结束的位置由于已经是分界线，不存在应该往前的，所以发现所有应该往前放的都会往前一位。而且这一段的开头一定不会是应该放在前面的。若是应该放在前面的，则一整段都是，又根据分界线，前面也都是，个数就不对了。 每个点最开始一定会被排一下，所以要和1取个max。 D.magic题意自己看。 做法先考虑暴力，$a+\\frac x y=\\frac {ay+x} {y}$，然后结合的时候可能还要倒过来。 $x$ 和 $y$ 互质，所以那个 $ay+x$ 和 $y$ 也互质。 所以就不用考虑约分，直接模意义下也可以做。 然后你发现把分子分母上矩阵，就可以做了。 我把线段树维护卡了，直接前缀和，处理矩阵的逆元。 THE END","link":"/2022-7-15%E6%A8%A1%E6%8B%9F%E8%B5%9B%E8%AE%B0/"},{"title":"ABC255比赛笔记","text":"比赛传送门 前言做出来 7 题，第一次做出 Ex，感觉还不错。 上一次做出 7 题还是在很久以前呢 /wx 为啥 ABC 前几题越来越难了啊，感觉 C 都有 D 的水平了。 交错程序一发，可真有我的。 题解E - Lucky Numbers题意有一个未知的长度为 $N$ 的数列 $A$ 满足 $A_i+A_{i+1}=S_i$，给定 $S$ 和一个大小为 $M$ 的集合 $X$，求最多有多少个 $i$ 满足 $A_i \\in X$。 $N \\le 10^6,M \\le 10,-10^9 \\le S_i,X_i \\le 10^9$ 做法Tag: 数学 先钦定 $A_1=0$，推出整个 $A$。 容易得到，如果 $A_1+1$，那么必定会有 $A_2-1,A_3+1,A_4-1,A_5+1\\dots$，即奇数下标的 $+1$，偶数下标的 $-1$。 对于每个奇数的 $i$ 处理出所有 $X_j-A_i$，对于每个偶数的 $i$ 处理出所有 $A_i-X_j$，这样就可以统计出 $A_1+W$ 后的答案，即为 $W$ 在统计中出现的次数。在左右出现次数中取最大值即可。 Code12345678910111213141516171819202122232425ll n, m, s[100005], x[20], a[100005], ans = 0;vector&lt;ll&gt;v;void solve() { cin &gt;&gt; n &gt;&gt; m; rep(i, n - 1)cin &gt;&gt; s[i]; rep(i, m)cin &gt;&gt; x[i]; forr(i, 1, n - 1)a[i] = s[i - 1] - a[i - 1]; rep(i, n) { rep(j, m) { ll tmp; if (i % 2 == 0)tmp = a[i] - x[j]; else tmp = x[j] - a[i]; v.pb(tmp); } } sort(v.begin(), v.end()); ll l, r = 0; while (r &lt; (ll)v.size()) { l = r; while (r + 1 &lt; (ll)v.size() &amp;&amp; v[r + 1] == v[l])r++; ans = max(ans, r - l + 1); r++; } cout &lt;&lt; ans;} F - Pre-order and In-order题意给出一棵树的前序遍历 $P$ 和中序遍历 $I$，求这棵树的形态，或判断无解。 $N \\le 2\\times 10^5$ 做法CSP 初赛经典题了属于是。 考虑 $P_{l\\dots r}$ 匹配 $I_{L\\dots R}$。 显然 $P_l$ 为根，所以就可将 $I$ 划分成两段，即 $P_l$ 的左边和右边。知道左右子树大小后，就可以将 $P_{L+1\\dots R}$ 划分成两段，递归即可。 如果 $P_l$ 在 $I_{L\\dots R}$ 中没有出现则判断无解。 Code12345678910111213141516171819202122int n, a[200005], b[200005], p[200005];int son[200005][2];bool ans = 1;void dfs(int l, int r, int L, int R) { if (l &gt; r || L &gt; R || !ans)return; int x = a[l], y = p[a[l]], lenl = y - L, lenr = R - y; if (y&lt;L || y&gt;R)ans = 0; if (lenl &gt; 0)son[x][0] = a[l + 1] + 1, dfs(l + 1, l + lenl, L, y - 1); if (lenr &gt; 0)son[x][1] = a[l + lenl + 1] + 1, dfs(l + lenl + 1, r, y + 1, R);}void solve() { cin &gt;&gt; n; rep(i, n)cin &gt;&gt; a[i], a[i]--; rep(i, n)cin &gt;&gt; b[i], b[i]--, p[b[i]] = i; if (a[0]) { cout &lt;&lt; -1; return; } dfs(0, n - 1, 0, n - 1); if (!ans)cout &lt;&lt; -1; else rep(i, n)cout &lt;&lt; son[i][0] &lt;&lt; ' ' &lt;&lt; son[i][1] &lt;&lt; endl;} G - Constrained Nim没看。 Ex - Range Harvest Query题意有 $N$ 棵树，第 $0$ 天它们都没有果子，每天晚上，第 $i$ 棵树会结出 $i$ 个果子。 共有 $Q$ 次采摘，第 $i$ 次在第 $D_i$ 天晚上，采走第 $L_i$ 到 $R_i$ 棵树上所有的果子。 对于每次采摘，输出采到了多少果子，对 $998244353$ 取模。 $N,D_i \\le 10^{18},Q \\le 2 \\times 10^5,D_i&lt;D_{i+1}$ 做法Tag: 数据结构，珂朵莉树 珂朵莉树模板题。 感谢 lxl！ 维护每棵树最后被采摘的区间，每次用等差数列求和处理区间贡献，再区间赋值即可。 由于每次操作只会 split 出 至多 $2$ 个区间，所以区间总数是 $O(Q)$ 的，并且查询复杂度和包含的区间个数有关，查询后会将这些区间全部合并到一起，所以最多只会查询 $O(Q)$ 个区间，算上 set 复杂度，总时间复杂度为 $O(Q \\log Q)$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct Node { ll l, r; mutable ll val; Node(ll a = -1, ll b = -1, ll c = 0) { l = a, r = b, val = c; } bool operator &lt; (const Node&amp; a) const { return l &lt; a.l; }};set&lt;Node&gt;s;bool cmp(pair&lt;ll, ll&gt;x, pair&lt;ll, ll&gt;y) { return x.first &lt; y.first;}set&lt;Node&gt;::iterator split(ll pos) { set&lt;Node&gt;::iterator it = s.lower_bound(Node(pos)); if (it != s.end() &amp;&amp; it-&gt;l == pos)return it; --it; Node tmp = *it; s.erase(it); s.insert(Node(tmp.l, pos - 1, tmp.val)); return s.insert(Node(pos, tmp.r, tmp.val)).first;}void assign(ll l, ll r, ll val) { set&lt;Node&gt;::iterator itr = split(r + 1), itl = split(l); s.erase(itl, itr); s.insert(Node(l, r, val));}ll qpow(ll a, ll x, ll y) { ll ans = 1; a %= y; while (x) { if (x &amp; 1)ans = (ans * a) % y; a = (a * a) % y; x &gt;&gt;= 1; } return ans;}ll e_2;ll query(ll l, ll r, ll d) { set&lt;Node&gt;::iterator itr = split(r + 1), itl = split(l); ll ans = 0; for (set&lt;Node&gt;::iterator it = itl; it != itr; it++) { ll L = it-&gt;l, R = it-&gt;r, lst = it-&gt;val; ll sum = (L % MOD + R % MOD) % MOD * ((R - L + 1) % MOD) % MOD * e_2 % MOD; ans = (ans + (d % MOD - lst) % MOD * sum % MOD) % MOD; } return (ans + MOD) % MOD;}ll n, q, d, l, r;void solve() { e_2 = qpow(2, MOD - 2, MOD); cin &gt;&gt; n &gt;&gt; q; s.insert(Node(1, n, 0)); while (q--) { cin &gt;&gt; d &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(l, r, d) &lt;&lt; endl; assign(l, r, d); }} 后记赛后难度出来了，果然 G&gt;Ex 呢 /hx","link":"/ABC255%E6%AF%94%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"title":"ARC155比赛笔记","text":"比赛传送门 发现自己的恶性循环：自闭打unr-&gt;打的挺好-&gt;自信满满打rated-&gt;掉分-&gt;自闭打unr A - ST and TS Palindrome 给定长度为 $n$ 的字符串 $S$ 和一个数 $k$，问是否存在一个长度为 $k$ 的字符串 $T$ 满足字符串 $S+T$ 和 $T+S$ 都是回文串。$n \\le 2\\cdot 10^5,k \\le 10^{18}$ Tag: 字符串 设 $S$ 倒转后得到 $S’$。 考虑如果 $k&gt;2n$，那么 $S’$ 必定是 $T$ 的前缀和后缀，设 $T=S’+t+S’$。 所以可以得到 $S+S’+t+S’$ 和 $S’+t+S’+S$ 都是回文串，进而得到 $S’+t$ 和 $t+S’$ 都是回文串。 简单分析可知，“$S’+t$ 和 $t+S’$ 都是回文串”与“ $S+t$ 和 $t+S$ 都是回文串”是等价的，所以整个转化过程就相当于把 $k$ 缩小了 $2n$。 这样一直转化下去，最后相当于把 $k$ 模上 $2n$。 之后分成 $k=0,1\\le k \\le n$ 和 $n+1\\le j \\le 2n-1$ 讨论，具体过程比较简单，这里就不赘述了。 Code 123456789101112131415161718192021222324252627282930ll n, k;string s, t;bool ans;bool check(string st) { rep(i, st.size())if (st[i] != st[st.size() - 1 - i])return 0; return 1;}void solve() { cin &gt;&gt; n &gt;&gt; k &gt;&gt; s; k %= 2 * n; if (!k)ans = check(s); else if (k &lt;= n) { t = s.substr(0, k); reverse(t.begin(), t.end()); ans = check(s + t) &amp; check(t + s); } else { t = &quot;&quot;; rep(i, k)t += '1'; rep(i, n)t[i] = s[n - 1 - i]; ans = 1; rep(i, n) { if (t[k - 1 - i] != '1' &amp;&amp; t[k - 1 - i] != s[i])ans = 0; t[k - 1 - i] = s[i]; } if (ans)ans = check(s + t) &amp; check(t + s); } if (ans)cout &lt;&lt; &quot;Yes\\n&quot;; else cout &lt;&lt; &quot;No\\n&quot;;} B - Abs Abs Function 有一个非负整数对的集合 $T$，初始时 $T={A,B}$。每次操作，要么向 $T$ 中加入一个元素，要么给定区间 $[l,r]$，查询 $\\min\\limits_{x\\in [l,r],(a,b)\\in T} \\lvert\\lvert x-a \\rvert -b \\rvert$。$q \\le 2\\cdot 10^5,A,B,l,r \\le 10^9$ Tag: 数学 查询的东西函数图像画出来是一个 W。其实可以转化成 $\\min{\\lvert a+b-x\\rvert,\\lvert a-b-x\\rvert}$。刚好它要求的也是 min，所以就拆成两个数 $a+b$ 和 $a-b$，查询改为 $\\min\\limits_{x\\in [l,r],y\\in T} \\lvert x-y\\rvert$。这个东西用 set 维护一下就行了。 Code 12345678910111213141516171819202122232425ll q, t, a, b;set&lt;ll&gt;s;void solve() { cin &gt;&gt; q &gt;&gt; a &gt;&gt; b; s.insert(a + b), s.insert(a - b); while (q--) { cin &gt;&gt; t &gt;&gt; a &gt;&gt; b; if (t == 1)s.insert(a + b), s.insert(a - b); else { auto p = s.lower_bound(a); ll ans = MAXN; if (p != s.end()) { int x = *p; if (x &lt;= b)ans = 0; else ans = x - b; } if (p != s.begin()) { p--; int x = *p; ans = min(ans, a - x); } cout &lt;&lt; ans &lt;&lt; endl; } }}","link":"/ARC155%E6%AF%94%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"title":"2023求真书院Pi节挑战赛试题及参考答案","text":"QwQ","link":"/2023%E6%B1%82%E7%9C%9F%E4%B9%A6%E9%99%A2Pi%E8%8A%82%E6%8C%91%E6%88%98%E8%B5%9B%E8%AF%95%E9%A2%98%E5%8F%8A%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/"},{"title":"CF1617E Christmas Chocolates","text":"「2023zimpha」树的直径练习题 题目传送门 有 $n$ 个互不相同的数 $a_1,a_2,\\dots,a_n$。 每次操作，选定一个数 $a_i$ 和一个非负整数 $k$ 满足 $2^k \\le a_i$，然后将 $a_i$ 替换为 $2^k-a_i$。 定义 $dis(a_i,a_j)$ 为最少需要的操作次数，使得 $a_i=a_j$（每次操作只能对 $a_i$ 使用）。 选出一对 $a_i,a_j$ 使 $dis(a_i,a_j)$ 最大。 $n \\le 2\\cdot 10^5, a_i \\le 10^9$ 在可以通过一次操作互相转化的两个数之间连一条边。 可以发现，这样建出来的图一定是一棵树（每个数都只能转化到唯一一个比自己小的数）。这棵树的根节点为 0。 原问题转化为：求在树上距离最大的一组 $a_i,a_j$。 用树的直径求法，先找到距离 $a_1$ 最远的点 $a_u$，再找到距离 $a_u$ 最远的点 $a_v$。那么 $a_u,a_v$​ 即为答案。 因为每次操作大概是除以二，所以点的深度是 log 级别。求距离可以用暴力跳，单次复杂度 log。 总复杂度 $O(n \\log n)$。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243int n, a[N];unordered_map&lt;int, int&gt; num;int cnt, fa[32 * N], dep[32 * N], zero;queue&lt;int&gt; q;int dis(int x, int y) { int d = 0; while(x != y) { if(dep[x] &gt;= dep[y]) x = fa[x]; else y = fa[y]; d++; } return d;}int u = 1, v = 1;set&lt;int&gt; s;void solve() { cin &gt;&gt; n; rep(i, n) { cin &gt;&gt; a[i]; num[a[i]] = i + 1; q.push(a[i]); } cnt = n; while(!q.empty()) { int x = q.front(); q.pop(); s.insert(x); if(!x) continue; int y = 1; while(y &lt; x) y *= 2; y = y - x; if(!num[y]) { num[y] = ++cnt; q.push(y); } fa[num[x]] = num[y]; } for(int i: s) if(i) dep[num[i]] = dep[fa[num[i]]] + 1; repp(i, n) if(dis(1, i) &gt; dis(1, u)) u = i; repp(i, n) if(dis(u, i) &gt; dis(u, v)) v = i; if(u &gt; v) swap(u, v); cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; ' ' &lt;&lt; dis(u, v);}","link":"/CF1617E-Christmas-Chocolates/"},{"title":"ABC285G Tatami","text":"AC 的第一道上下界网络流。 题目传送门 用若干个 $1 \\times 1$ 和 $1 \\times 2$ 的瓷砖（可以旋转）不重叠地完全覆盖 $H \\times W$ 的长方形网格。第 $i$ 行第 $j$ 列的网格有限制 $c_{i,j}$，含义如下： 1：该网格只能用 $1 \\times 1$ 的瓷砖覆盖。 2：该网格只能用 $1 \\times 2$ 的瓷砖覆盖。 ?：无限制。 判断是否可行。 $H,W \\le 300$ 因为有 $1\\times 1$ 的瓷砖比较自由，所以我们只需要考虑满足所有限制为 2 的格子就行了。 显然，按照 $i+j$ 的奇偶性可以将网格分成一个二分图。 对于两个相邻且可以用一个 $1\\times 2$ 覆盖的格子（即都不是 1），连一条 $[0,1]$ 的边。 接着考虑每个点的流量限制： 对于 1，没有流量，不用连边。 对于 2，必须要用 $1\\times 2$ 覆盖，向超级源点/汇点连一条 $[1,1]$ 的边。 对于 ?，可以用 $1\\times 2$ 覆盖，也可以不用，向超级源点/汇点连一条 $[0,1]$ 的边。 然后用有源汇上下界可行流求解。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495int n, m;string s[N];char c[N][N];int id(int x, int y) { return (x - 1) * m + y - 1; }int S, T, S2, T2;int in[N * N], out[N * N];int cnt = -1;int w[20 * N * N], to[20 * N * N], dep[20 * N * N];vector&lt;int&gt;g[N * N];void addedge2(int x, int y, int v) { // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ' &lt;&lt; v &lt;&lt; endl; if (!v)return; ++cnt; w[cnt] = v, to[cnt] = y; g[x].pb(cnt); ++cnt; w[cnt] = 0, to[cnt] = x; g[y].pb(cnt);}void addedge(int x, int y, int l, int r) { // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; ' ' &lt;&lt; l &lt;&lt; ',' &lt;&lt; r &lt;&lt; endl; in[y] += l, out[x] += l; addedge2(x, y, r - l);}int sum = 0;bool bfs() { init(dep, 0); dep[S2] = 1; queue&lt;int&gt; q; q.push(S2); while (!q.empty()) { int x = q.front(); q.pop(); for (int y : g[x]) if (w[y] &amp;&amp; !dep[to[y]]) { dep[to[y]] = dep[x] + 1; q.push(to[y]); } } return (dep[T2] != 0);}int dfs(int x, int mn) { if (x == T2) return mn; int tmp = mn; for (int y : g[x]) { if (dep[to[y]] != dep[x] + 1 || !w[y]) continue; int v = dfs(to[y], min(mn, w[y])); w[y] -= v; if (y % 2 == 0) w[y + 1] += v; else w[y - 1] += v; mn -= v; if (!mn)break; } if (tmp == mn) dep[x] = 0; return tmp - mn;}void solve() { cin &gt;&gt; n &gt;&gt; m; S = n * m, T = S + 1, S2 = T + 1, T2 = S2 + 1; addedge(T, S, 0, MAXN); rep(i, n)cin &gt;&gt; s[i]; repp(i, n)repp(j, m)c[i][j] = s[i - 1][j - 1]; repp(i, n)repp(j, m) { if ((i + j) % 2 == 0) { if (c[i][j] == '2')addedge(S, id(i, j), 1, 1); if (c[i][j] == '?')addedge(S, id(i, j), 0, 1); } else { if (c[i][j] == '2')addedge(id(i, j), T, 1, 1); if (c[i][j] == '?')addedge(id(i, j), T, 0, 1); } } repp(i, n)repp(j, m) { if (c[i][j] == '1')continue; rep(k, 2) { int x = i + k, y = j + 1 - k; if (c[x][y] == '2' || c[x][y] == '?') { if ((i + j) % 2 == 0)addedge(id(i, j), id(x, y), 0, 1); else addedge(id(x, y), id(i, j), 0, 1); } } } rep(i, T + 1) { if (in[i] &gt; out[i])addedge2(S2, i, in[i] - out[i]), sum += in[i] - out[i]; if (in[i] &lt; out[i])addedge2(i, T2, out[i] - in[i]); } while (bfs())sum -= dfs(S2, MAXN); if (!sum)cout &lt;&lt; &quot;Yes&quot;; else cout &lt;&lt; &quot;No&quot;;}","link":"/ABC285G-Tatami/"},{"title":"CF1680F Lenient Vertex Cover","text":"题目传送门 DFS 树的性质。 首先注意到题面中的这一句话： 最多只能有一条边，满足两个顶点都在这个点集中。 显然，“最多只能有一条边”意思就是有 $0$ 条或 $1$ 条。 0 条所以每条边都恰好只有一个顶点在点集中。 很自然想到二分图染色，每条边两个顶点颜色不同。 所以只要这个图是二分图，就一定有解。 1 条有一条边的两个点同色，那么去掉这个边后，剩下的图一定就是一个二分图，就转化成了上一个情况。 先 DFS 一遍。一个显然的重要的性质是：对于原图中的每条边，要么是 DFS 树中的一条边，要么是一条返祖边（即一个点连向它祖先的边）。 因为二分图中没有奇环，所以这条去掉的边一定在所有奇环上，而不能在任何一个偶环上（这样去掉之后就全是偶环了）。 考虑去掉什么边。 返祖边因为一个环在 DFS 树中一定是一条链加上一条返祖边，所以在 DFS 遇到返祖边时判断这个环是奇环还是偶环，就能统计出奇环数量了。如果奇环数量为 $1$，那么直接去掉那条返祖边即可。 树边在统计环时把环上的所有树边都标记 $+1$，最后看是否有一个树边满足： 所在的奇环数 $=$ 奇环总数 所在的偶环数 $=0$ 即可。 标记时用树上差分即可，不会的同学可以左转 OI Wiki。 最后判断答案时只需要再 DFS 一遍，按照深度奇偶性染色即可。 注意：有可能结果是：一条边满足两个顶点都不在点集中，其他每条边都有一个顶点在点集中。这时候只需要把所有颜色反转即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576int n, m, a[1000006], b[1000006];vector&lt;vector&lt;int&gt;&gt;v;int dep[1000006], fa[1000006], d1[1000006], d2[1000006], s1[1000006], s2[1000006];int cnt;int del1, del2;void dfs(int k, int from) { rep(i, v[k].size()) { int x = v[k][i]; if (x == from)continue; if (dep[x]) { if (dep[x] &lt; dep[k]) { if ((dep[k] - dep[x]) % 2 == 0)d1[x]--, d1[k]++, del1 = x, del2 = k, cnt++; else d2[x]--, d2[k]++; } continue; } dep[x] = dep[k] + 1; fa[x] = k; dfs(x, k); }}pair&lt;int, int&gt; dfs2(int k) { pair&lt;int, int&gt;tmp, sum; sum.fi = d1[k], sum.se = d2[k]; rep(i, v[k].size()) { int x = v[k][i]; if (fa[x] != k)continue; tmp = dfs2(x); sum.fi += tmp.fi, sum.se += tmp.se; } if (sum.fi == cnt &amp;&amp; sum.se == 0)del1 = fa[k], del2 = k; return sum;}int ans[1000006];void getans(int k) { rep(i, v[k].size()) { if (ans[v[k][i]] != -1)continue; if (k == del1 &amp;&amp; v[k][i] == del2)continue; if (k == del2 &amp;&amp; v[k][i] == del1)continue; ans[v[k][i]] = 1 - ans[k]; getans(v[k][i]); }}void solve() { cnt = 0; cin &gt;&gt; n &gt;&gt; m; v.resize(n); rep(i, n)v[i].clear(); rep(i, m) { cin &gt;&gt; a[i] &gt;&gt; b[i]; a[i]--, b[i]--; v[a[i]].pb(b[i]); v[b[i]].pb(a[i]); } rep(i, n)ans[i] = -1, dep[i] = d1[i] = d2[i] = 0; dep[0] = 1; del1 = del2 = -1; dfs(0, -1); if (cnt &gt; 1) { del1 = del2 = -1; dfs2(0); if (del1 == -1) { cout &lt;&lt; &quot;NO\\n&quot;; return; } } ans[0] = 0; getans(0); rep(i, m)if (!ans[a[i]] &amp;&amp; !ans[b[i]]) { rep(j, n)ans[j] = 1 - ans[j]; break; } cout &lt;&lt; &quot;YES\\n&quot;; rep(i, n)cout &lt;&lt; ans[i]; cout &lt;&lt; '\\n';}","link":"/CF1680F-Lenient-Vertex-Cover/"},{"title":"CF1672E notepad.exe","text":"「2023zimpha」二分练习题 题目传送门 交互题。 文本编辑器中有 $n$ 个单词，第 $i$ 个长度为 $l_i$。$l$ 仅对测评机可见。 文本编辑器一行一行展示文本，以空格分开相邻的两个单词，但是行末不一定有空格，即单词可以直接作为某一行的末尾。对于给定的屏幕宽度 $w$，高度 $h$ 为展示文本最少需要的行数。 如果 $w \\le \\max(l_i)$，那么文本编辑器将崩溃， $h = 0$ . 最多可以询问 $n + 30$ 次。每次询问宽度 $w$ 。测评机将返回 $h$。 输出最小面积，即 $min(w\\times h_w)$。 $n,l_i \\le 2000$ 良题。 看到 $n+30$，可以猜到询问是二分+ $O(n)$ 枚举。 先二分出最小的 $w=w_1$ 满足 $h=1$，即把所有单词放在一行的长度。 此时如果有更优的 $h$，最小宽度为 $w_h$，那么一定有 $w_h \\le \\left\\lfloor \\dfrac{w_1}{h}\\right \\rfloor$。 对比 $h$ 行与 $1$ 行两种方案，考虑最优的情况，$h$ 行每行末尾都没有空格，那么就在 $1\\sim h-1$ 行的末尾各省下了一个空格，共 $h-1$ 个，所以又有 $w_h\\cdot h \\ge w_1-h+1$，进一步，$w_h \\ge \\dfrac{w1-h+1}{h} \\ge \\left\\lfloor \\dfrac{w_1}{h}\\right \\rfloor$。 所以可以得到 $w_h=\\left\\lfloor \\dfrac{w_1}{h}\\right \\rfloor$。 接下来，我们就可以枚举 $2 \\le h \\le n$，然后对 $w=\\left\\lfloor \\dfrac{w_1}{h}\\right \\rfloor$ 询问，用 $w\\cdot h’$ 更新答案（$h’$ 为测评机返回的数）。 Code 12345678910111213141516171819202122ll n, w, a, ans;void solve() { cin &gt;&gt; n; ll l = 1, r = 2000 * 3000, mid; while (l &lt;= r) { mid = (l + r) / 2; cout &lt;&lt; &quot;? &quot; &lt;&lt; mid &lt;&lt; endl; cout.flush(); cin &gt;&gt; a; if (a == 1)w = mid, r = mid - 1; else l = mid + 1; } ans = w; repp(i, n) { cout &lt;&lt; &quot;? &quot; &lt;&lt; w / i &lt;&lt; endl; cout.flush(); cin &gt;&gt; a; if (a)ans = min(ans, w / i * a); } cout &lt;&lt; &quot;! &quot; &lt;&lt; ans &lt;&lt; endl; cout.flush();}","link":"/CF1672E-notepad-exe/"},{"title":"CF455C Civilization","text":"「2023zimpha」树的直径练习题 题目传送门 给出一个有 $n$ 个点，$m$ 条边的森林，有 $q$ 次操作。操作有两种： 查询点 $x$ 所在树的直径 要求添加一条边，合并点 $x$ 和 $y$ 所在的两棵树，使合并后树的直径最小。（如果 $x$ 和 $y$ 在同一棵树中则不用操作） $n,m,q \\le 3\\cdot 10^5$ 设添加的边的两个端点为 $u,v$，两棵树直径分别为 $d_1,d_2$。 使合并后树的直径最小，也就是使经过 $u,v$ 的最长路径最短，这条路径的长度为 $dis(u,u’)+dis(v,v’)+1$，其中 $u’,v’$ 分别是合并前两棵树中的点。 考虑最小化 $dis(u,u’)$，那么就是要在找到一个 $u$，使得它到树中其他点距离的最大值最小。 这里有一个经典结论，从一个点到树中其他的最长路径，另一端点一定是这棵树直径的一个端点。所以我们选的 $u$ 一定是直径的中点（若直径为奇数则中间两个点任取一个）。因此 $\\max(dis(u,u’))=\\left\\lceil\\dfrac{d_1}{2}\\right\\rceil$。 所以，合并后树的最小直径就是 $\\max\\left(d1,d2,\\left\\lceil\\dfrac{d_1}{2}\\right\\rceil+\\left\\lceil\\dfrac{d_2}{2}\\right\\rceil\\right)$。 用并查集合并即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int n, m, q, op, u, v;vector&lt;int&gt; g[N];int fa[N];int Find(int i) { if(fa[i] == i) return i; else return fa[i] = Find(fa[i]);}int mx, id;int d[N];void dfs(int x, int f, int cnt) { if(cnt &gt; mx) mx = cnt, id = x; for(int y: g[x]) { if(y == f) continue; dfs(y, x, cnt + 1); }}int div2(int x) { if(!x) return 0; else return (x - 1) / 2 + 1;}void solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; rep(i, n) fa[i] = i; rep(i, m) { cin &gt;&gt; u &gt;&gt; v; u--, v--; g[u].pb(v), g[v].pb(u); fa[Find(u)] = Find(v); } memset(d, -1, sizeof(d)); rep(i, n) if(d[Find(i)] == -1) { mx = -1; dfs(i, -1, 0); mx = -1; dfs(id, -1, 0); d[Find(i)] = mx; } while(q--) { cin &gt;&gt; op; if(op == 1) { cin &gt;&gt; u; u--; cout &lt;&lt; d[Find(u)] &lt;&lt; '\\n'; } else { cin &gt;&gt; u &gt;&gt; v; u--, v--; if(Find(u) == Find(v)) continue; else { d[Find(v)] = max(max(d[Find(u)], d[Find(v)]), div2(d[Find(u)]) + div2(d[Find(v)]) + 1); fa[Find(u)] = Find(v); } } }}","link":"/CF455C-Civilization/"},{"title":"Codeforces Hello 2023 比赛笔记","text":"vp 的，做出来 ABCDF。 比赛传送门 C. Least Prefix Sum题意给定一个长度为 $n$ 的数组 $a$，和一个数 $m$，每次可以花 $1$ 代价把一个数 $\\times -1$，求最少要多少代价使得对于每个 $k\\in[1,n]$：$$\\sum\\limits_{i=1}^k a_i\\ge \\sum\\limits_{i=1}^m a_i$$$n\\le 2\\cdot 10^5$ 题解Tag: 贪心，数据结构 先考虑 $k&lt;m$ 的情况。 如果 $\\sum_{i=1}^k a_i&lt; \\sum_{i=1}^m a_i$，说明需要调整，而且一定是将 $k&lt;i\\le m$ 且 $a_i&gt;0$ 的 $a_i\\times -1$，才能使不等式的右式值变小。我们肯定是希望改变的 $a_i$ 越大越好。 所以我们把下标从 $m-1$ 扫到 $1$，同时用 priority_queue 维护还没有调整过的 $a_i$。如果遇到需要调整的，就从 pq 中取出一个最大值，同时 ans++。（这个思路类似 CF3D Least Cost Bracket Sequence） $k&gt;m$ 的情况类似，就是把正负反一下。 Code1234567891011121314151617181920212223242526272829303132333435ll n, m, a[200005], cnt, ans;ll pre[200005];priority_queue&lt;ll&gt;pq;void solve() { cin &gt;&gt; n &gt;&gt; m; m--; ans = cnt = 0; while (!pq.empty())pq.pop(); rep(i, n) { cin &gt;&gt; a[i]; cnt += a[i]; pre[i] = cnt; } if (a[m] &gt; 0)pq.push(a[m] * 2); for (int i = m - 1;i &gt;= 0;i--) { while (pre[i] &lt; pre[m]) { ans++; pre[m] -= pq.top(); pq.pop(); } if (a[i] &gt; 0)pq.push(a[i] * 2); } cnt = 0; while (!pq.empty())pq.pop(); forr(i, m + 1, n - 1) { cnt += a[i]; if (a[i] &lt; 0)pq.push(a[i] * -2); while (cnt &lt; 0) { ans++; cnt += pq.top(); pq.pop(); } } cout &lt;&lt; ans &lt;&lt; endl;} D. Boris and His Amazing Haircut题意给定长度为 $n$ 的数组 $a,b$，你的目标是将 $a$ 变成 $b$。 你有 $m$ 种操作，每种有一个参数 $x$。你可以选择一个区间 $[l,r]$，然后对于每个 $i\\in [l,r],a_i:=\\min(a_i,x)$。每种操作只能使用一次。可能有多种操作的参数一样。 询问可行性。 $n,m \\le 2\\cdot 10^5,a_i,b_i,c_i \\le 10^9$ 题解Tag: 数据结构 首先判断：如果有 $a_i&lt;b_i$ 则无解。 可以发现，对 $i$ 使用一个 $x&gt;b_i$ 的操作是没有影响的。所以我们按照 $b_i$ 从小到大来处理。设现在处理到 $v$，那么所有 $b_i\\le v$ 的位置都可以使用操作。这些位置形成了一些极长的段，我们数出有多少段包含需要改变的位置（$b_i=v$ 且 $a_i\\not=b_i$），如果数量大于参数为 $v$ 的操作数量则无解。 可以用并查集维护每个位置在哪一段。最开始我的写法是：每处理过一个位置 $i$，则把 $i-1,i,i+1$ 所在的段都合并到一起。这样会被类似 2,1,3,1,2 的数据卡掉（然而 WA#72，不得不说数据真水）。正确的做法是在处理 $i$ 前判断 $i-1,i+1$ 是否已经处理过了，处理过就合并。 同时还要判断是否有 $i$ 使得 $a_i\\not= b_i$ 且不存在一个操作的参数 $=b_i$，这样也是无解的。我的实现是对于每个处理过的位置打上标记，最后看有没有位置没有标记。 要离散化。注意数组开大几倍。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int N = 2000006;int n, m, a[N], b[N], x[N];vector&lt;int&gt;v;int siz;int fa[N];int getf(int i) { if (fa[i] == i)return i; return fa[i] = getf(fa[i]);}vector&lt;vector&lt;int&gt;&gt;p;int cnt[N];set&lt;int&gt;s;bool vis[N];void solve() { v.clear(); cin &gt;&gt; n; rep(i, n)cin &gt;&gt; a[i], v.pb(a[i]); rep(i, n)cin &gt;&gt; b[i], v.pb(b[i]); cin &gt;&gt; m; rep(i, m)cin &gt;&gt; x[i], v.pb(x[i]); sort(v.begin(), v.end()); siz = unique(v.begin(), v.end()) - v.begin(); rep(i, n)a[i] = lower_bound(v.begin(), v.begin() + siz, a[i]) - v.begin(); rep(i, n)b[i] = lower_bound(v.begin(), v.begin() + siz, b[i]) - v.begin(); rep(i, m)x[i] = lower_bound(v.begin(), v.begin() + siz, x[i]) - v.begin(); rep(i, n)if (a[i] &lt; b[i]) { cout &lt;&lt; &quot;NO\\n&quot;; return; } rep(i, n)fa[i] = i; p.resize(siz); rep(i, siz)p[i].clear(), cnt[i] = 0; rep(i, n)p[b[i]].pb(i); rep(i, m)cnt[x[i]]++; rep(i, n)vis[i] = 0; rep(i, n - 1)if (b[i] == b[i + 1])fa[getf(i)] = getf(i + 1); rep(i, siz) { for (int j : p[i]) { if (j &amp;&amp; b[j - 1] &lt; b[j])fa[getf(j - 1)] = getf(j); if (j &lt; n - 1 &amp;&amp; b[j + 1] &lt; b[j])fa[getf(j)] = getf(j + 1); } s.clear(); for (int j : p[i])if (a[j] != b[j])s.insert(getf(j)); if (cnt[i] &lt; s.size()) { cout &lt;&lt; &quot;NO\\n&quot;; return; } for (int j : p[i])vis[j] = 1; } rep(i, n)if (!vis[i]) { cout &lt;&lt; &quot;NO\\n&quot;; return; } cout &lt;&lt; &quot;YES\\n&quot;;} E. Anya’s Simultaneous Exhibition题意交互题。 有 $n$ 个人，两两之间有胜负关系。定义一个 tourment 为：$n-1$ 场淘汰赛，最后一个人胜出。称一个人为 candidate master 当且仅当合适安排赛程后他能在 tourment 中胜出。 你可以进行至多 $2n$ 场模拟。在每场模拟中，你可以让一个人依次对战另外一些人。交互库会返回他赢的次数。请你最后输出有多少人可以成为 candidate master。 $n\\le 250$ 题解赛时没做出来。 以后补。 F. Xorcerer’s Stones题意给定一个树，节点 $i$ 权值为 $a_i$。你可以执行至多 $2n$ 次操作，每次操作可以将一个子树内所有点变成它们的异或和。求一种可行方案使得所有数变成 $0$。无解输出 $-1$。 $n\\le 2\\cdot 10^5,0\\le a_i \\le 31$ 题解Tag: 数学，DP 可以发现，如果对大小为奇数的子树执行操作，所有权值的异或和不变；如果对大小为偶数的子树执行操作，则子树内异或和变为 $0$。而当我们将整棵树的异或和变为 $0$ 后，只需要再对整棵树进行一次操作即可全部清零。 设 $f_{i,j}=0/1$ 表示能否使以 $i$ 为根的子树内异或和为 $j$。从子节点转移上来即可。如果以 $i$ 为根的子树大小为偶数，则 $f_{i,0}=1$ ，即对这棵树执行一次操作。 恶心的是居然要输出方案！写个路径还原，同时如果是执行操作的地方要打上标记。 这样做好像只要 $n$ 次操作？ 时间复杂度 $O(nw^2)$，其中 $w=32$。$2\\cdot 10^5 \\times 32^2\\approx 2\\cdot 10^8$。给了 4s，能过。 Code赛时写的代码操作次数有点多。这里放下优化后的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const int N = 200005;int n, a[N], fa, son[N], siz[N];vector&lt;int&gt;g[N];vector&lt;int&gt;dp[N][32];void dfs(int x) { rep(i, 32)rep(j, son[x] + 1)dp[x][i][j] = -1; dp[x][a[x]][0] = 0; siz[x] = 1; rep(i, son[x]) { int y = g[x][i]; dfs(y); siz[x] += siz[y]; rep(m1, 32)rep(m2, 32) { if (dp[x][m1][i] != -1 &amp;&amp; dp[y][m2][son[y]] != -1) { dp[x][m1 ^ m2][i + 1] = m2; } } } if (siz[x] % 2 == 0)dp[x][0][son[x]] = -2;}vector&lt;int&gt;ans;void getans(int x, int val) { if (dp[x][val][son[x]] == -2) { ans.pb(x + 1); return; } for (int i = son[x] - 1;i &gt;= 0;i--) { int y = g[x][i]; getans(y, dp[x][val][i + 1]); val ^= dp[x][val][i + 1]; }}void solve() { cin &gt;&gt; n; rep(i, n)cin &gt;&gt; a[i]; rep(i, n - 1) cin &gt;&gt; fa, fa--, son[fa]++, g[fa].pb(i + 1); rep(i, n)rep(j, 32)dp[i][j].resize(son[i] + 1); dfs(0); if (dp[0][0][son[0]] == -1)cout &lt;&lt; -1; else { getans(0, 0); ans.pb(1); cout &lt;&lt; ans.size() &lt;&lt; endl; for (int x : ans)cout &lt;&lt; x &lt;&lt; ' '; }}","link":"/Codeforces-Hello-2023-%E6%AF%94%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"title":"FFT字符串匹配","text":"用 FFT 解决（带通配符的）字符串匹配。 普通字符串匹配设 $S$ 为模式串，$T$ 为文本串，$n=\\lvert S \\rvert,m=\\lvert T \\rvert$（字符串下标从 $0$ 开始）。 显然，两个字符串相同，当且仅当它们每一位都相同，这是一句废话。 我们联想到初中一年级的一句重要的话：**如果若干个非负数的和为 $0$，那么它们都为 $0$**。 和为 $0$ 正好对应了 每一位都相同，所以很容易得出这个 完全匹配函数（很重要！之后要考） $$f(x)=\\sum\\limits_{i=0}^{n-1} (S_i-T_{x-n+i+1})^2$$ $f(x)$ 表示 $S$ 与 $T_{(x-n+1)\\dots x}$ 的 匹配值 。 其中平方是为了保证每一项都是非负数。这样，只有每一项都为 $0$（即 $S_i=T_{x+i-1}$），$f(x)$ 才会为 $0$。 显然这个柿子不是很好化简，所以我们要对它进行一点点的变形。 什么柿子容易计算呢？当然是卷积，即： $$f(x)=\\sum\\limits_{i+j=x} A_iB_j$$ 然而之前那个柿子中，$i$ 和 $x-n+i+1$ 加起来显然不是一个定值。如何把这个 $i$ 消掉呢？ 我们考虑把 $S$ 整个串反转，这样原来的 $i$ 就变成了 $n-i-1$。 于是变成： $$f(x)=\\sum\\limits_{i=0}^{n-1} (S_{n-i+1}-T_{x-n+i+1})^2$$ 两个下标相加： $$(n-i+1)+(x-n+i+1)=x$$ 好耶！消掉了！ 于是那个柿子就可以写成： $$f(x)=\\sum\\limits_{i+j=x}(S_i-T_j)^2$$ 用完全平方公式拆开： $$f(x)=\\sum\\limits_{i+j=x}S_i^2-2S_iT_j+T_j^2$$ 显然第一项和第三项可以预处理得到，第二项就是 $S\\cdot T$ 中 $x$ 次项的系数乘上 $-2$，只需要把 $S$ 和 $T$ 看成多项式，FFT 相乘即可。 复杂度 $O(n \\log n)$。 带通配符的字符串匹配通配符，即可以匹配任意字符的字符（当然也可以匹配通配符）。 显然这种问题 KMP 就无能为力了。然而，对于 FFT 做法，我们仍然可以用相似的思路解决。 我们发现，原来 完全匹配函数 为 $0$，当且仅当对应的两个字符相同。但是，现在有了通配符，条件应该改为满足以下两个中任意一个： 对应两个字符相同 对应两个字符中有任意一个是通配符 很容易想到设通配符为 $0$（当然其它任何字符都不能为 $0$）。完全匹配函数 就变成了： $$f(x)=\\sum\\limits_{i=0}^{n-1} (S_i-T_{x-n+i+1})^2 \\cdot S_iT_j$$ 如果 $S_i=0$ 或 $T_i=0$，那么 $f(x)$ 仍然为 $0$。 老规矩，反转 $S$： $$f(x)=\\sum\\limits_{i=0}^{n-1} (S_{n-i+1}-T_{x-n+i+1})^2 \\cdot S_iT_j$$ 化成卷积形式： $$f(x)=\\sum\\limits_{i+j=x}(S_i-T_j)^2 \\cdot S_iT_j$$ 完全平方公式： $$f(x)=\\sum\\limits_{i+j=x}S_i^3T_j-2S_i^2T_j^2+S_iT_j^3$$ 看起来很复杂？但每一项还是卷积的形式，于是就用很多次 FFT 解决了。 复杂度 $O(n \\log n)$。 例题模板题残缺的字符串 Luogu 传送门 黑暗爆炸OJ 传送门 做法就是模板题，按上面方法做就完了。 注意数组大小好好算，$eps$ 我取的 $1$ 过了。 常数有点大，吸氧能过。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const double pi = acos(-1);int T_, case_;int n1, n2, n = 1, len = 0;string s, t;int S[MAXN], T[MAXN];struct Complex { double r, i; Complex() { r = i = 0; } Complex(double r_, double i_) :r(r_), i(i_) {}; Complex operator+(const Complex&amp; x)const { return Complex(r + x.r, i + x.i); }; Complex operator-(const Complex&amp; x)const { return Complex(r - x.r, i - x.i); }; Complex operator*(const Complex&amp; x)const { return Complex(r * x.r - i * x.i, i * x.r + r * x.i); };};int rev[MAXN];void FFT(Complex* a, int f) { rep(i, n)if (i &lt; rev[i])swap(a[i], a[rev[i]]); repp(d, log2(n)) { int l = 1 &lt;&lt; d; Complex wn = Complex(cos(2.0 * pi / l), f * sin(2.0 * pi / l)); for (int i = 0;i &lt; n;i += l) { Complex w = Complex(1, 0); rep(j, l / 2) { Complex t = w * a[i + j + l / 2], u = a[i + j]; a[i + j] = u + t; a[i + j + l / 2] = u - t; w = w * wn; } } } if (f == -1)rep(i, n)a[i].r /= n;}Complex a[MAXN], b[MAXN], ans[MAXN];vector&lt;int&gt;v;void solve() { cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; s &gt;&gt; t; reverse(s.begin(), s.end()); while (n &lt; n1 + n2)n *= 2, len++; rep(i, n)rev[i] = (rev[i / 2] / 2 | ((i &amp; 1) &lt;&lt; (len - 1))); rep(i, n1)S[i] = (isalpha(s[i]) ? s[i] - 'a' + 1 : 0); rep(i, n2)T[i] = (isalpha(t[i]) ? t[i] - 'a' + 1 : 0); rep(i, n)a[i] = Complex(S[i] * S[i] * S[i], 0), b[i] = Complex(T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = a[i] * b[i]; rep(i, n)a[i] = Complex(S[i] * S[i], 0), b[i] = Complex(T[i] * T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = ans[i] - Complex(2, 0) * a[i] * b[i]; rep(i, n)a[i] = Complex(S[i], 0), b[i] = Complex(T[i] * T[i] * T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = ans[i] + a[i] * b[i]; FFT(ans, -1); forr(i, n1 - 1, n2 - 1)if (fabs(ans[i].r) &lt;= 1)v.pb(i - n1 + 2); if (v.empty()) { cout &lt;&lt; 0; return; } cout &lt;&lt; v.size() &lt;&lt; endl; rep(i, v.size())cout &lt;&lt; v[i] &lt;&lt; ' ';} 练习题CF528D Fuzzy Search Luogu 传送门 Codeforces 传送门 题目大意有两个字符串 $S,T$，长度分别为 $n,m$，字符集为 ${A,C,G,T}$，和一个整数 $k$。 我们称 $S$ 在 $T$ 的第 $i$ 位出现了，当且仅当把 $S$ 的首字符和 $T$ 的第 $i$ 个字符对齐后，$S$ 中的每一个字符能够在 $T$ 中找到一个位置偏差不超过 $k$ 的相同字符。 即对于所有的 $j \\in[1,n]$，都存在一个 $p \\in [1,m]$ 使得 $|(i+j-1)-p| \\leq k$ 且 $S_p=T_j$ 。 请求出 $S$ 在 $T$ 中出现的次数。 做法首先把四种字母分开来考虑，最后取四个集合的交即可。 接下来假设只考虑字母 A，其余三个同理。 先把 $S$ 和 $T$ 除了 A 的部分都去掉（即空白），其余位置涂色。 接下来对 $T$ 处理：由于 $T$ 中的一个 A（假设在第 $i$ 位）可以影响到 $[i-k,i+k]$ 这些位置，所以把这些位置全都涂色。 接下来直接匹配即可。对于 $S$ 上有颜色的位置，$T$ 对应位置一定要有颜色；而对于 $S$ 上空白的位置，$T$ 对应位置可以有颜色，也可以是空白。 于是把 $T$ 的涂色部分看成 $1$，空白部分看成 $2$，$S$ 的涂色部分看成 $1$，空白部分看成 $0$（即通配符）。 复杂度 $O(n \\log n)$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const double pi = acos(-1);int T_, case_;int n1, n2, n = 1, len = 0, k;string s, t;int S[MAXN], T[MAXN];struct Complex { double r, i; Complex() { r = i = 0; } Complex(double r_, double i_) :r(r_), i(i_) {}; Complex operator+(const Complex&amp; x)const { return Complex(r + x.r, i + x.i); }; Complex operator-(const Complex&amp; x)const { return Complex(r - x.r, i - x.i); }; Complex operator*(const Complex&amp; x)const { return Complex(r * x.r - i * x.i, i * x.r + r * x.i); };};int rev[MAXN];void FFT(Complex* a, int f) { rep(i, n)if (i &lt; rev[i])swap(a[i], a[rev[i]]); repp(d, log2(n)) { int l = 1 &lt;&lt; d; Complex wn = Complex(cos(2.0 * pi / l), f * sin(2.0 * pi / l)); for (int i = 0;i &lt; n;i += l) { Complex w = Complex(1, 0); rep(j, l / 2) { Complex t = w * a[i + j + l / 2], u = a[i + j]; a[i + j] = u + t; a[i + j + l / 2] = u - t; w = w * wn; } } } if (f == -1)rep(i, n)a[i].r /= n;}Complex a[MAXN], b[MAXN], ans[MAXN];char C[] = { 'A','C','G','T' };int d;int sum[MAXN], SUM = 0;void solve() { cin &gt;&gt; n2 &gt;&gt; n1 &gt;&gt; k &gt;&gt; t &gt;&gt; s; reverse(s.begin(), s.end()); while (n &lt; n1 + n2)n *= 2, len++; rep(i, n)rev[i] = (rev[i / 2] / 2 | ((i &amp; 1) &lt;&lt; (len - 1))); rep(c, 4) { rep(i, n1)S[i] = (s[i] == C[c]); d = 0; rep(i, min(k, n2))d += (t[i] == C[c]); rep(i, n2) { if (i + k &lt; n2)d += (t[i + k] == C[c]); T[i] = (d &gt; 0 ? 1 : 2); if (i - k &gt;= 0)d -= (t[i - k] == C[c]); } rep(i, n)a[i] = Complex(S[i] * S[i] * S[i], 0), b[i] = Complex(T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = a[i] * b[i]; rep(i, n)a[i] = Complex(S[i] * S[i], 0), b[i] = Complex(T[i] * T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = ans[i] - Complex(2, 0) * a[i] * b[i]; rep(i, n)a[i] = Complex(S[i], 0), b[i] = Complex(T[i] * T[i] * T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = ans[i] + a[i] * b[i]; FFT(ans, -1); forr(i, n1 - 1, n2 - 1)if (fabs(ans[i].r) &lt;= 1)sum[i - n1 + 1]++; } rep(i, n2 - n1 + 1)if (sum[i] == 4)SUM++; cout &lt;&lt; SUM;}","link":"/FFT%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"title":"POJ1874 Trade on Verweggistan","text":"题目传送门 本题最大难点：读题。 首先说一下题意： 有 $w$ 堆货物，第 $i$ 堆有 $b_i$ 个，从上往下给定每个货物的进价。所有货物的售价都是 $10$，但是如果想买一件货物，必须要先买在它上面的所有货物。求出最大利润，以及要达成这个利润，需要买多少个货物，可能有多种方案，从小到大输出。如果超过 $10$ 个只需要输出最小的 $10$ 个。 显然先把每堆的前缀和从大到小排序，最大利润就是每堆 rk1 的前缀和加起来。 比较烦的是有的堆前缀和可能 $\\le 0$。 这里有个小 trick：每堆在排序时加一个元素 $(0,0)$，表示前 $0$ 个的利润和是 $0$。这样就可以挤掉 $\\le 0$ 的情况。 接下来处理货物数。 最小就是每堆 rk1 的长度的和，贪心计算出接下来最小的方案是什么：遍历一遍现有的所有方案，算出所有拓展的方式取 min，然后把这种方案加到答案队伍里。要去重。已经有 $10$ 个不重复的就 break。 注意： $b$ 有可能是 $0$ 输出格式，每组数据之间要空一行 实在不行去 udebug 上找组数据测测 加了 IO 优化才过。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt;v;int rk[20000][55];void solve() { v.resize(n); cnt = 0; rep(i, n) { cin &gt;&gt; m; sum = 0; v[i].clear(); v[i].pb(mp(0, 0)); rep(j, m) { cin &gt;&gt; a; sum += 10 - a; v[i].pb(mp(-sum, j + 1)); } sort(v[i].begin(), v[i].end()); } sum = 0; rep(i, n)sum -= v[i][0].fi; ans = 1; cnt = 1; init(rk[0], 0); rep(i, n) rk[0][n] += v[i][0].se; rep(I, 10000) { int mn = MAXN, id1, id2; rep(i, ans) { rep(j, n) { if (rk[i][j] &lt; 0 || rk[i][j] &gt;= (int)v[j].size() - 1 || v[j][rk[i][j] + 1].fi != v[j][rk[i][j]].fi)continue; if (rk[i][n] + v[j][rk[i][j] + 1].se - v[j][rk[i][j]].se &lt; mn) { mn = rk[i][n] + v[j][rk[i][j] + 1].se - v[j][rk[i][j]].se; id1 = i; id2 = j; } } } if (mn == MAXN)break; rep(i, n)rk[ans][i] = rk[id1][i]; rk[ans][id2]++; rk[id1][id2] = -1; rk[ans][n] = mn; if (rk[ans][n] != rk[ans - 1][n])cnt++; ans++; if (cnt == 10)break; } cout &lt;&lt; &quot;Workyards &quot; &lt;&lt; T_ &lt;&lt; endl; cout &lt;&lt; &quot;Maximum profit is &quot; &lt;&lt; sum &lt;&lt; &quot;.\\n&quot;; cout &lt;&lt; &quot;Number of pruls to buy:&quot;; rep(i, ans)if (!i || rk[i][n] != rk[i - 1][n])cout &lt;&lt; ' ' &lt;&lt; rk[i][n]; cout &lt;&lt; endl;}int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); T_ = 1; while (cin &gt;&gt; n) { if (!n)break; if (T_ &gt; 1)cout &lt;&lt; endl; solve(); T_++; } return 0;} 另一种也许可行的办法 爆搜出所有方案，放到 set 里去找到前十。上次 CSP-J 被 set 坑到 TLE ，就没敢用。","link":"/POJ1874-Trade-on-Verweggistan/"},{"title":"URAL1095 Nikifor 3","text":"题目传送门 打表找规律。 首先你得先打个表，就像这样： 123456int a[] = { 1,2,3,4 };do { int x = 0; rep(i, 4) cout &lt;&lt; a[i], x = x * 10 + a[i]; cout &lt;&lt; ' ' &lt;&lt; x % 7 &lt;&lt; endl;} while (next_permutation(a, a + 4)); 然后你就能惊讶地发现，对于每个 $i\\in [1,7]$，都有至少一个 $1,2,3,4$ 的排列满足：$(组成的四位数)\\equiv i\\pmod i$。 所以考虑先在字符串中去掉 $1,2,3,4$，将剩余的所有数字放在最后面，并处理出这串数 $\\bmod 7$ 是多少，然后把 $1,2,3,4$ 按照某种顺序放在最前面就行了。 之所以要把剩余部分放在最后面而不是最前面的原因是，如果有这样一组数据：001234，就会出现前导零。 Code 12345678910111213141516171819202122232425262728293031323334353637int T_, case_;int A[7][4], sum, p;string s, t;bool f[5];void solve() { sum = 0; init(f, 0); cin &gt;&gt; s; t = &quot;&quot;; p = 1; rep(i, s.size()) { int x = s[i] - '0'; if (x &gt;= 1 &amp;&amp; x &lt;= 4 &amp;&amp; !f[x])f[x] = 1; else { t += s[i]; p = p * 10 % 7; sum = (sum * 10 + x) % 7; } } rep(i, 7)if ((i * p + sum) % 7 == 0) { rep(j, 4)cout &lt;&lt; A[i][j]; cout &lt;&lt; t &lt;&lt; endl; }}int main() { init(A, -1); int a[] = { 1,2,3,4 }; do { int x = 0; rep(i, 4) x = x * 10 + a[i]; if (A[x % 7][0] == -1)rep(i, 4)A[x % 7][i] = a[i]; } while (next_permutation(a, a + 4)); T_ = 1; cin &gt;&gt; T_; for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;}","link":"/URAL1095-Nikifor-3/"},{"title":"USACO2018FEB P New Barns","text":"「2023zimpha」树的直径练习题 题目传送门 有一棵树，初始没有节点。有 $q$ 次操作，操作分两种： 新建一个节点，将它与 $p$ 节点连接。（若 $p=-1$，则不与其它节点相连 ） 查询在 $k$ 节点所在的连通块中，距它最远的点的距离。 $q \\le 10^5$。 树的直径入门题目。 经典结论：树中距离一个节点最远的点一定是直径的两个端点之一。证明见 OI Wiki。 于是我们只需要维护树的直径，先把所有操作离线下来，建出最终的树，倍增求 LCA。新加节点时用两个直径端点到它的距离更新直径即可。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int q, n = 0, p[N], fa[N][20], dep[N];char op[N];int dis(int x, int y) { if (dep[x] &lt; dep[y]) swap(x, y); int X = x, Y = y; for (int i = 19; i &gt;= 0; i--) { if (fa[X][i] != -1 &amp;&amp; dep[fa[X][i]] &gt;= dep[Y]) { X = fa[X][i]; } } if (X == Y) return dep[x] - dep[X]; for (int i = 19; i &gt;= 0; i--) { if (fa[X][i] != -1 &amp;&amp; fa[Y][i] != -1 &amp;&amp; fa[X][i] != fa[Y][i]) { X = fa[X][i]; Y = fa[Y][i]; } } return dep[x] - dep[X] + dep[y] - dep[Y] + 2;}int rt[N], d[N][2], cnt = -1;void solve() { cin &gt;&gt; q; rep(i, q) { cin &gt;&gt; op[i] &gt;&gt; p[i]; if (p[i] != -1) p[i]--; if (op[i] == 'B') { if (p[i] != -1) dep[n] = dep[p[i]] + 1, rt[n] = rt[p[i]]; else rt[n] = n; fa[n++][0] = p[i]; } } repp(i, 19) { rep(j, n) { if (fa[j][i - 1] == -1) fa[j][i] = -1; else fa[j][i] = fa[fa[j][i - 1]][i - 1]; } } rep(i, q) { if (op[i] == 'B') { ++cnt; if (p[i] == -1) d[cnt][0] = d[cnt][1] = cnt; else { int x = d[rt[p[i]]][0], y = d[rt[p[i]]][1]; if (dis(x, cnt) &gt; dis(d[rt[p[i]]][0], d[rt[p[i]]][1])) { d[rt[p[i]]][0] = x; d[rt[p[i]]][1] = cnt; } if (dis(y, cnt) &gt; dis(d[rt[p[i]]][0], d[rt[p[i]]][1])) { d[rt[p[i]]][0] = y; d[rt[p[i]]][1] = cnt; } } } else { int x = d[rt[p[i]]][0], y = d[rt[p[i]]][1]; cout &lt;&lt; max(dis(x, p[i]), dis(y, p[i])) &lt;&lt; endl; } }}","link":"/USACO2018FEB-P-New-Barns/"},{"title":"CF1775E The Human Equation","text":"题目传送门 题意给定一个长度为 $n$ 的数组 $a$。每次操作，你可以选出 $a$ 的一个子序列 $b$ ，然后将 $b$ 中奇数位+1，偶数位-1；或者奇数位-1，偶数位+1。求最少多少次操作能使所有数变成 $0$。 $n \\le 2\\cdot 10^5$ 题解发现如果有相邻的两个数 $x,y$ 正负性相同，那么将它们合并为 $x+y$ 是不影响的。 根据这个，我们先把 $a$ 中能合并的都合并了，合并之后，$a$ 中任意相邻两个数正负性都不同。 显然，我们不会把一个正数+1，或者把一个负数-1。所以每次操作一定是把每个正数-1，每个负数+1（因为现在的数组是奇偶相间的）。 当数组中一个数被加/减到 0 的时候，我们将其从数组中删去，同时合并它的左右两个数（这两个数正负性一定相同）。直到数组被清空为止。我们用链表来维护数组，multiset 维护最小值，同时维护现在的时刻。数组清空时的时刻就是答案。 Code1234567891011121314151617181920212223242526272829303132333435363738ll n, a, ans;vector&lt;ll&gt;v;int l[200005], r[200005];multiset&lt;pair&lt;ll, int&gt;&gt;s;void solve() { cin &gt;&gt; n; v.clear(); ans = 0; rep(i, n) { cin &gt;&gt; a; if (!a)continue; if (v.empty() || (v.back() &gt; 0 &amp;&amp; a &lt; 0) || (v.back() &lt; 0 &amp;&amp; a &gt; 0))v.pb(a); else v.back() += a; } n = v.size(); rep(i, n) { if (i)l[i] = i - 1; else l[i] = n; if (i &lt; n - 1)r[i] = i + 1; else r[i] = n; } rep(i, n)v[i] = abs(v[i]), s.insert(mp(v[i], i)); while (!s.empty()) { auto it = s.begin(); int x = (*it).se; ans = v[x]; r[l[x]] = r[x], l[r[x]] = l[x]; s.erase(it); if (l[x] != n &amp;&amp; r[x] != n) { int L = l[x], R = r[x]; s.erase(mp(v[L], L)), s.erase(mp(v[R], R)); v[L] += v[R] - ans; r[L] = r[R], l[r[R]] = L; s.insert(mp(v[L], L)); } } cout &lt;&lt; ans &lt;&lt; endl;}","link":"/CF1775E-The-Human-Equation/"},{"title":"SPOJ BTCODE_A - Traversing Grid","text":"题目传送门 简单妙妙题。 题意有四种点的变换，分别是把点 $(x,y)$ 变成 $(y,x),(x,-y),(x+y,y),(2\\cdot x,y)$。 给定起点 $(x_s,y_s)$ 和终点 $(x_d,y_d)$，问能否通过若干次变换将起点变为终点。 题解结论：答案为 Yes 当且仅当 $\\gcd(x_s,y_s)\\cdot 2^k=\\gcd(x_d,y_d)$。 容易发现，除了第四种变换，其他三种变换后 $\\gcd(x,y)$ 都不变，而第四种变换后 $\\gcd(x,y)$ 最多 $\\times 2$。所以最后 $\\gcd(x,y)$ 只能是乘上一个 2 的整数次幂。这样我们就证明了必要性。 接下来证明充分性：发现前三项其实做的就是辗转相减，所以最后一定可以变成 $(\\gcd(x_s,y_s),0)$。再经过若干次变换 4，可以变成 $(\\gcd(x_d,y_d))$。又可以发现，四种操作全都可逆，所以可以逆着辗转相减，最后就能变成 $(x_d,y_d)$。 于是就证明了结论是充要的。 Code123456789101112131415161718192021bool check(ll x, ll y) { for (ll p = 1;x * p &lt;= y;p *= 2ll) { if (x * p == y)return 1; } return 0;}void solve() { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; if (a == 0 &amp;&amp; b == 0) { if (c == 0 &amp;&amp; d == 0)cout &lt;&lt; &quot;YES\\n&quot;; else cout &lt;&lt; &quot;NO\\n&quot;; return; } if (c == 0 &amp;&amp; d == 0) { cout &lt;&lt; &quot;NO\\n&quot;; return; } e = __gcd(abs(a), abs(b)), f = __gcd(abs(c), abs(d)); if (f % e == 0 &amp;&amp; check(e, f))cout &lt;&lt; &quot;YES\\n&quot;; else cout &lt;&lt; &quot;NO\\n&quot;;}","link":"/SPOJ-BTCODE-A-Traversing-Grid/"},{"title":"USACO2023JAN G 比赛笔记","text":"打得还行，希望能晋级P。 T1. Find and Replace 有一个字符串 $S$，初始为单个字符 a。有 $n$ 次操作，每次给定字符 $c$ 和字符串 $s$，将 $S$ 中所有 $c$ 替换为 $s$。操作结束后给定 $l,r$，询问 $S_{l\\dots r}$。$\\sum \\lvert s \\rvert \\le 2\\cdot 10^5,r-l+1\\le 2\\cdot 10^5$ Tag: 搜索 设 $f_{i,j}$ 表示字符 $i$ 经过操作 $j,j+1\\dots n$ 后会变为多少个字符。则可以根据 $f$ 的值 DFS（类似线段树查询，一层层拆分区间，$f$ 的值即为区间大小）。 这样会遇到一个问题：如果存在大量 $\\lvert s \\rvert =1$，即一个字符变为一个字符，那么 DFS 中操作次数可能达到 $O(n^2)$ 次。对此，可以预处理出字符 $i$ 在操作 $j$ 后第一个 $\\lvert s \\rvert &gt;1$ 的操作 $nxt_{i,j}$，以及在操作 $nxt_{i,j}$ 时字符 $i$ 变成了字符 $to_{i,j}$。这样可以快速跳转至下一个增加 $S$ 长度的操作。 由于每次有效操作都会将 $S$ 长度至少+1，而 $r-l+1\\le 2\\cdot 10^5$，所以需要处理的操作也不会超过这个数。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243char c[N];string s[N];ll dp[26][N], nxt[26][N], to[26][N];ll L, R, n;void dfs(ll x, ll d, ll p, ll l, ll r) { // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; d &lt;&lt; endl; if (d == n) { cout &lt;&lt; char('a' + x); return; } rep(i, s[d].size()) { int y = s[d][i] - 'a'; ll w = dp[y][d + 1]; if (p &lt;= r &amp;&amp; p + w - 1 &gt;= l)dfs(to[y][d + 1], nxt[y][d + 1], p, max(p, l), min(p + w - 1, r)); p += w; if (p &gt; r)break; }}void solve() { cin &gt;&gt; L &gt;&gt; R &gt;&gt; n; rep(i, n)cin &gt;&gt; c[i] &gt;&gt; s[i]; rep(i, 26)dp[i][n] = 1, nxt[i][n] = n, to[i][n] = i; for (int j = n - 1;j &gt;= 0;--j) rep(i, 26) { if (c[j] - 'a' != i) { dp[i][j] = dp[i][j + 1]; nxt[i][j] = nxt[i][j + 1]; to[i][j] = to[i][j + 1]; } else if (s[j].size() == 1) { dp[i][j] = dp[s[j][0] - 'a'][j + 1]; nxt[i][j] = nxt[s[j][0] - 'a'][j + 1]; to[i][j] = to[s[j][0] - 'a'][j + 1]; } else { dp[i][j] = 0, nxt[i][j] = j, to[i][j] = i; rep(k, s[j].size()) { dp[i][j] += dp[s[j][k] - 'a'][j + 1]; dp[i][j] = min(dp[i][j], (ll)MAXN * MAXN); } } } dfs(0, 0, 1, L, R);} T2. Lights OffTag: 数学 有两个二进制数 $a,b$，每次操作，先将 $b$ 的一位取反，然后将 $a$ 异或上 $b$，最后将 $b$ 在二进制下循环右移一位。问至少几次操作让 $a=0$。多测，数据组数 $\\le 2\\cdot 10^5$，所有测试点中 $a,b$ 在二进制下位数相同且 $\\le 20$。 考虑将一位反转会对结果造成什么影响，发现一定是异或上连续的一串1，而由于每次操作内只能反转一次，所以每种长度的一串1有且仅有一个。于是可以预处理一个背包 $f_{i,j}$ 表示长度为 $1\\dots i$ 的串异或起来能否得到 $j$。询问时枚举答案即可。 不太清楚是怎么证明答案 $\\le n$ 的。 Code 123456789101112131415161718192021222324252627282930313233343536373839int T_ = 1, case_;int n;bool dp[21][1 &lt;&lt; 21];int shift(int x) { int y = x % 2; return y * (1 &lt;&lt; (n - 1)) + x / 2;}string s, t;int a, b;void solve() { cin &gt;&gt; s &gt;&gt; t; a = b = 0; rep(i, n)a = a * 2 + s[i] - '0', b = b * 2 + t[i] - '0'; int now = 0; rep(i, n + 1) { if (dp[i][(a ^ now)]) { cout &lt;&lt; i &lt;&lt; endl; return; } now = shift(now) ^ b; }}int main() { // ios::sync_with_stdio(0); // cin.tie(0), cout.tie(0); cin &gt;&gt; T_ &gt;&gt; n; dp[0][0] = 1; int p[21]; init(p, 0); rep(i, n) { rep(j, n)p[j] = shift(p[j]) ^ (1 &lt;&lt; j); rep(msk, (1 &lt;&lt; n)) { if (!dp[i][msk])continue; rep(j, n)dp[i + 1][(msk ^ p[j])] = 1; } } for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;} T3. Moo Rute 一条长度为 $n+1$ 的链，节点标号为 $0 \\dots n$。从 0 开始走，每步向左或向右一个节点。已知每条边的经过次数 $a_i$，求在掉头次数最少的前提下，有多少种方案。$n \\le 10^5,a_i \\le 10^6$ 只写了个 $n=2$ 的部分分，组合数随便搞搞。 正解不知道怎么做。 UPD 2023/3/24：晋级了 先只考虑 $n=2$ 时的情况： 若 $a_1&gt;a_2$，答案为 $\\dbinom{a_1/2}{a_2/2}$ 若 $a_1 \\le a_2$，答案为 $\\dbinom{a_2/2-1}{a_1/2-1}$ 稍加思考可以知道，$n$ 更大的情况其实就相当于若干个 $n=2$ 连起来，相乘即可。 Code 1234567891011121314151617181920212223242526ll n, a[100005], ans = 1;ll f[1000006];ll qpow(ll x, ll y) { ll p = 1; while (y) { if (y &amp; 1)p = p * x % mod; x = x * x % mod; y &gt;&gt;= 1; } return p;}ll C(ll x, ll y) { return f[x] * qpow(f[y], mod - 2) % mod * qpow(f[x - y], mod - 2) % mod;}ll Solve(int a, int b) { if (a &gt; b)return C(a / 2, b / 2); else return C(b / 2 - 1, a / 2 - 1);}void solve() { cin &gt;&gt; n; rep(i, n)cin &gt;&gt; a[i]; f[0] = 1; repp(i, 1000000)f[i] = f[i - 1] * i % mod; rep(i, n - 1)ans = ans * Solve(a[i], a[i + 1]) % mod; cout &lt;&lt; ans;}","link":"/USACO2023JAN-G-%E6%AF%94%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"title":"UVA1063 Marble Game","text":"题目传送门 说是题解其实是 debug 记（叹气） 显然 BFS，状态我是用 vector&lt;vector&lt;int&gt;&gt; 来存每个格子上的 Marble 编号，洞可以根据这个推出来，就不用存。 转移时，枚举向四个方向移动。这里写四个函数可能会比较烦，我的做法是，对于 $n\\in [0,4]$，先将盘面顺时针转 $n\\cdot 90^\\circ$，再将所有 Marble 向左移动，最后将盘面顺时针旋转 $(4-n)\\cdot 90^\\circ$。 注意： 旋转时，Marble，洞和墙都要旋转。 移动时，如果 Marble 掉进了对应的洞里，就把这个 Marble 和洞都删掉，如果掉进了别人的洞里，就不进行这个方向的转移。 输出格式，impossible 首字母小写，如果答案是 1 仍然是 moves 而不是 move。 然后，我就 WA 啦。 找 gzy 的程序对拍了下，放一下生成数据的代码： 1234567891011121314151617181920212223242526272829303132333435363738int a[5][5], b[5][5], cnt;int x[16];template &lt;class T&gt;T randint(T l, T r = 0) { static mt19937 eng(time(0)); if (l &gt; r) swap(l, r); uniform_int_distribution&lt;T&gt; dis(l, r); return dis(eng);}int dx[] = { -1,0,0,1 };int dy[] = { 0,-1,1,0 };void solve() { rep(T, 1000) { rep(i, 16)x[i] = i; random_shuffle(x, x + 16); cnt = 0; rep(i, 4)rep(j, 4)a[i][j] = x[cnt++]; rep(i, 16)x[i] = i; random_shuffle(x, x + 16); cnt = 0; rep(i, 4)rep(j, 4)b[i][j] = x[cnt++]; int M = randint(1, 8), W = randint(0, 10); bool f = 0; rep(i, 4)rep(j, 4)if (a[i][j] &lt; M &amp;&amp; b[i][j] &lt; M)f = 1; if (f == 1)continue; cout &lt;&lt; 4 &lt;&lt; ' ' &lt;&lt; M &lt;&lt; ' ' &lt;&lt; W &lt;&lt; endl; rep(s, M) rep(i, 4)rep(j, 4)if (a[i][j] == s)cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; endl; rep(s, M) rep(i, 4)rep(j, 4)if (b[i][j] == s)cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; endl; while (W--) { int A = randint(1, 2), B = randint(1, 2), C = randint(0, 3); cout &lt;&lt; A &lt;&lt; ' ' &lt;&lt; B &lt;&lt; ' ' &lt;&lt; A + dx[C] &lt;&lt; ' ' &lt;&lt; B + dy[C] &lt;&lt; endl; } } cout &lt;&lt; &quot;0 0 0\\n&quot;;} 拍出来几个问题： 输入数据中下标是从 0 开始的 多测记得清空 每次移动后，Marble 和洞都要还原成移动前的位置 记录每个 Marble 是否出现的数组要开至少 8 大小 拍出来问题的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Input 14 3 70 12 00 32 11 13 22 2 3 21 2 1 31 1 2 12 1 2 22 2 3 22 2 3 21 2 1 1Output 1impossibleInput 24 8 90 01 02 03 03 13 23 32 31 22 22 11 10 10 20 31 30 0 0 11 0 1 12 0 2 12 1 3 12 2 3 22 2 2 31 2 1 30 2 1 21 1 1 2Output 225 moves Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100int n, m, w, A, B, C, D;bool operator&lt;(vector&lt;vector&lt;int&gt;&gt; A, vector&lt;vector&lt;int&gt;&gt; B) { repp(i, n)repp(j, n)if (A[i][j] != B[i][j])return A[i][j] &lt; B[i][j]; return 0;}bool operator==(vector&lt;vector&lt;int&gt;&gt; A, vector&lt;vector&lt;int&gt;&gt; B) { repp(i, n)repp(j, n)if (A[i][j] != B[i][j])return 0; return 1;}vector&lt;vector&lt;int&gt;&gt; a(5), b(5), x(5), y(5), cpy(5);bool f[5][5][5][5], f_[5][5][5][5], F[100];map&lt;vector&lt;vector&lt;int&gt;&gt;, int&gt;vis;void rotate(int N) { while (N--) { repp(i, n)repp(j, n)cpy[i][j] = x[n + 1 - j][i]; x = cpy; repp(i, n)repp(j, n)cpy[i][j] = y[n + 1 - j][i]; y = cpy; repp(i1, n)repp(j_1, n)repp(i2, n)repp(j2, n)f_[i1][j_1][i2][j2] = f[n + 1 - j_1][i1][n + 1 - j2][i2]; repp(i1, n)repp(j_1, n)repp(i2, n)repp(j2, n)f[i1][j_1][i2][j2] = f_[i1][j_1][i2][j2]; }}bool move() { repp(i, n) { repp(j, n) { if (!x[i][j])continue; int k = j; while (k &gt; 1 &amp;&amp; !f[i][k - 1][i][k] &amp;&amp; !x[i][k - 1]) { x[i][k - 1] = x[i][k]; x[i][k] = 0; k--; if (y[i][k] == x[i][k]) { x[i][k] = y[i][k] = 0; break; } if (y[i][k] &amp;&amp; y[i][k] != x[i][k])return 0; } } } return 1;}int bfs() { queue&lt;pair&lt;vector&lt;vector&lt;int&gt;&gt;, int&gt;&gt;q; q.push(mp(a, 0)); vis[a] = T_; while (!q.empty()) { x = q.front().fi; int val = q.front().se; q.pop(); init(F, 0); bool tmp = 0; repp(i, n)repp(j, n)if (x[i][j])F[x[i][j]] = tmp = 1; if (!tmp)return val; repp(i, n)repp(j, n) { if (F[b[i][j]])y[i][j] = b[i][j]; else y[i][j] = 0; } vector&lt;vector&lt;int&gt;&gt;xx = x, yy = y; bool suc; suc = move(); if (suc &amp;&amp; vis[x] != T_)q.push(mp(x, val + 1)), vis[x] = T_; x = xx, y = yy; rotate(1); suc = move(); rotate(3); if (suc &amp;&amp; vis[x] != T_)q.push(mp(x, val + 1)), vis[x] = T_; x = xx, y = yy; rotate(2); suc = move(); rotate(2); if (suc &amp;&amp; vis[x] != T_)q.push(mp(x, val + 1)), vis[x] = T_; x = xx, y = yy; rotate(3); suc = move(); rotate(1); if (suc &amp;&amp; vis[x] != T_)q.push(mp(x, val + 1)), vis[x] = T_; } return -1;}void solve() { repp(i, n)a[i].resize(5), b[i].resize(5), x[i].resize(5), y[i].resize(5), cpy[i].resize(5); repp(i, n)repp(j, n)a[i][j] = b[i][j] = 0; repp(i, n)repp(j, n)repp(ii, n)repp(jj, n)f[i][j][ii][jj] = 0; repp(i, m) { cin &gt;&gt; A &gt;&gt; B; a[A + 1][B + 1] = i; } repp(i, m) { cin &gt;&gt; A &gt;&gt; B; b[A + 1][B + 1] = i; } repp(i, w) { cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D; A++, B++, C++, D++; f[A][B][C][D] = f[C][D][A][B] = 1; } int ans = bfs(); if (ans == -1) cout &lt;&lt; &quot;Case &quot; &lt;&lt; T_ &lt;&lt; &quot;: impossible\\n\\n&quot;; else cout &lt;&lt; &quot;Case &quot; &lt;&lt; T_ &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; &quot; moves\\n\\n&quot;;}","link":"/UVA1063-Marble-Game/"},{"title":"百度之星2022初赛游记","text":"做的是第二场。 看别人打的第一场做了 7 题还 100+ 名，一开题感觉一道都不会做，很慌。 最后做出来 5 题，66 名，很开心。 做题顺序：$1\\rightarrow 3 \\rightarrow 7 \\rightarrow 5 \\rightarrow 4$ 这场显然偶数题比奇数题难。 1. 和题意给定一个长为 $n$ 的序列，有 $q$ 次询问，每次询问 $[l,r]$ 区间内最大的 $k$ 个数之和是否 $\\ge x$。 $n,q \\le 10^5,k\\le 10,a_i \\le 10^4,x\\le 10^8$ 做法第一遍写了莫队，用 set 维护，显而易见 TLE 了。（不过这个我还写了好久 /lh） 由于 $k$ 十分小，所以用线段树维护区间内前 $k$ 小的值，合并什么的总之就是非常暴力。 复杂度 $O(nk \\log k+qk\\log nk)$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546int a[100005];int n, q, k, x;int tree[400005][21], cnt[400005];void build(int node, int l, int r) { if (l == r) { cnt[node] = 1; tree[node][0] = a[l]; return; } int mid = l + r &gt;&gt; 1; build(ls, l, mid); build(rs, mid + 1, r); cnt[node] = 0; rep(i, cnt[ls])tree[node][cnt[node]++] = tree[ls][i]; rep(i, cnt[rs])tree[node][cnt[node]++] = tree[rs][i]; sort(tree[node], tree[node] + cnt[node]); reverse(tree[node], tree[node] + cnt[node]); cnt[node] = min(cnt[node], k);}vector&lt;int&gt;ans;void query(int node, int l, int r, int L, int R) { if (L &lt;= l &amp;&amp; r &lt;= R) { rep(i, cnt[node])ans.pb(tree[node][i]); return; } int mid = l + r &gt;&gt; 1; if (mid &gt;= L)query(ls, l, mid, L, R); if (mid &lt; R)query(rs, mid + 1, r, L, R);}int l, r, sum;void solve() { cin &gt;&gt; n &gt;&gt; q &gt;&gt; k &gt;&gt; x; rep(i, n)cin &gt;&gt; a[i]; build(0, 0, n - 1); while (q--) { cin &gt;&gt; l &gt;&gt; r; ans.clear(); query(0, 0, n - 1, l - 1, r - 1); sum = 0; sort(ans.begin(), ans.end()); reverse(ans.begin(), ans.end()); rep(i, min((int)ans.size(), k))sum += ans[i]; if (sum &gt;= x)cout &lt;&lt; &quot;Y\\n&quot;; else cout &lt;&lt; &quot;N\\n&quot;; }} 3. 逃离这棵树题意给定一棵大小为 $n$ 的树，根节点为 $1$，每个点有权重 $p_i$，$i$ 到 $j$ 的边有权重 $q_{i,j}$。 当站在点 $i$ 上时，下一步有 $\\frac{p_i}{p_i+\\sum q_{i,j}}$ 的概率留在原地，有 $\\frac{q_{i,j}}{p_i+\\sum q_{i,j}}$ 的概率到 $j$ 节点（$j$ 为 $i$ 的儿子）。 初始时在根节点，问期望多少步后到达叶节点，对 $998244353$ 取模。 $n \\le 10^6,p_i,q_{i,j}\\le 10$ 做法做法类似于某场 ABC 的 E 题，只是把数轴换成了树。然而我至今没有补掉那个题，但是赛时把这个题切了。 设 $dp_i$ 为 $i$ 期望走多少步到叶节点。 考虑枚举从 $i$ 下一步到达的点 $j$，$j$ 对 $i$ 的答案的贡献是 $\\frac{q_{i,j}}{p_i+\\sum q_{i,j}} \\cdot dp_j$。 另外，$i$ 节点期望要 $\\frac{p_i+\\sum q_{i,j}}{p_i}$ 步离开原地，所以 $dp_i$ 还要再加上这个数。 代码12345678910111213141516171819202122232425262728293031323334353637383940const int MOD = 998244353;ll qpow(ll x, ll y) { ll p = 1; while (y) { if (y &amp; 1)p = p * x % MOD; x = x * x % MOD; y &gt;&gt;= 1; } return p;}ll inv(ll x) { return qpow(x, MOD - 2); }int n, p[1000006], q[1000006];vector&lt;vector&lt;int&gt;&gt;v;ll dp[1000006];void dfs(int x) { if (v[x].empty()) { dp[x] = 0; return; } ll sum = 0; for (int y : v[x]) { dfs(y); sum += q[y]; } ll INV = inv(sum); dp[x] = (sum + p[x]) * INV; for (int y : v[x])dp[x] = (dp[x] + q[y] * INV % MOD * dp[y] % MOD) % MOD;}void solve() { cin &gt;&gt; n; rep(i, n) cin &gt;&gt; p[i]; v.resize(n); repp(i, n - 1) { int a; cin &gt;&gt; a &gt;&gt; q[i]; v[a - 1].pb(i); } dfs(0); cout &lt;&lt; dp[0];} 4. 通信网络题意给定一个 $n$ 个点，$m$ 条边的无向图，一条边 $(u,v,w)$ 表示这条边连接 $u$ 和 $v$，长度为 $w$。有 $q$ 次询问，每次询问给定 $k$ 个关键点，第 $i$ 个关键点为 $p_i$，与这个点的距离 $\\le d_i$ 的节点会被打上标记。对于每次询问，输出有多少个点被打上了标记。询问之间独立，也就是每次打上的标记会在下一次询问前清空。 $n \\le 10^3,m \\le 10^4,q \\le 10^5,\\sum k \\le 10^6,w \\le 10^6,d_i \\le 10^9$ 做法把询问离线下来，对于每个关键点分别处理。 对于每个询问一个 bitset $ans_i$，$ans_{i,j}$ 表示在第 $i$ 次询问中，$j$ 是否被打上了标记。 对于每个关键点 $x$，把和它有关的询问按照 $d$ 从小到大排序。 维护一个 bitset $res$，$res_i$ 表示 $i$ 与 $x$ 的距离是否 $\\le d$。容易发现，由于 $d$ 已经从小到大排序过了，所以 $res$ 中的元素只会从 $0$ 变成 $1$，或者不变。 所以先跑一边 dijkstra，处理出所有点到 $x$ 的距离，然后把所有点按照与 $x$ 的距离排序，单调地往 $res$ 中加入就可以了。处理到第 $i$ 个询问时，把 $ans_i$ 按位或上 $res$，最后答案就是 $ans_i.count()$。 复杂度 $O(n^2\\log n+nm \\log m+k \\log k+\\frac{nk}{\\omega})$，能过。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int n, m, q, a, b, c;int dist[1010];int k;vector&lt;pair&lt;int, int&gt;&gt;g[1010], v[1010];bitset&lt;1010&gt;ans[100005], tmp;priority_queue&lt;pair&lt;int, int&gt;&gt;pq;int id[1010];void solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; rep(i, m) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; a--, b--; g[a].pb(mp(b, c)); g[b].pb(mp(a, c)); } rep(i, q) { cin &gt;&gt; k; rep(j, k) { cin &gt;&gt; a &gt;&gt; b; v[a - 1].pb(mp(b, i)); } } rep(i, n) { if (v[i].empty())continue; init(dist, 63); dist[i] = 0; pq.push(mp(0, i)); while (!pq.empty()) { int val = -pq.top().fi, x = pq.top().se; pq.pop(); if (val != dist[x])continue; if (g[x].size())rep(j, g[x].size()) { int y = g[x][j].fi, w = g[x][j].se; if (dist[y] &gt; val + w) { dist[y] = val + w; pq.push(mp(-dist[y], y)); } } } tmp.reset(); rep(i, n)id[i] = i; sort(id, id + n, [&amp;](int x, int y) {return dist[x] &lt; dist[y];}); sort(v[i].begin(), v[i].end()); int p = 0; rep(j, v[i].size()) { while (p &lt; n &amp;&amp; dist[id[p]] &lt;= v[i][j].fi) { tmp[id[p]] = 1; p++; } ans[v[i][j].se] |= tmp; } } rep(i, q)cout &lt;&lt; ans[i].count() &lt;&lt; endl;} 5. 星球联通题意给定三维空间内的 $n$ 个点，表示一个点的坐标为 $(x,y,z)$，连接两个点的代价是它们距离的平方。 现在可以免费连接 $k$ 个点，额外再连接 $i$ 个点（即一共连接 $k+i$ 个点）需要花 $c_i$ 的代价。 求将所有点连通起来的最小代价。 $k \\le n \\le 3000,c_i \\le 10^9,x,y,z \\le 10^4$ 做法显然枚举额外连接多少个星球，现在问题变成： 给定一张带权完全图，连接其中 $x$ 个点，代价最少是多少。 容易联想到最小生成树的 Kruskal 算法。改一下： 把边按边权从小到大依次检查，如果连接的两个点不在同一个连通分量里，就把这条边加进去。当有 $x-1$ 条边时结束。 这个看上去就很对的算法实际上也是对的，正确性易证，但是我不会证，大概和 Kruskal 的证法差不多。 代码123456789101112131415161718192021222324252627282930ll n, k, c[3010], x[3010], y[3010], z[3010], ans, sum, cnt;vector &lt; pair&lt;ll, pair&lt;int, int&gt;&gt;&gt;v;int fa[3010];int getf(int i) { if (fa[i] == i)return i; return fa[i] = getf(fa[i]);}void solve() { cin &gt;&gt; n &gt;&gt; k; repp(i, n - k)cin &gt;&gt; c[i]; rep(i, n)cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; z[i]; rep(i, n)forr(j, i + 1, n - 1) { ll X = x[i] - x[j], Y = y[i] - y[j], Z = z[i] - z[j]; ll val = X * X + Y * Y + Z * Z; v.pb(mp(val, mp(i, j))); } sort(v.begin(), v.end()); rep(i, n)fa[i] = i; ans = c[n - k], sum = 0, cnt = n - k; rep(i, v.size()) { int a = v[i].se.fi, b = v[i].se.se; if (getf(a) == getf(b))continue; cnt--; fa[getf(a)] = getf(b); sum += v[i].fi; ans = min(ans, sum + c[cnt]); if (!cnt)break; } cout &lt;&lt; ans;} 7. 原地传送题意有一个 $n\\times m$ 的网格图，起点为 $(0,0)$，终点为 $(n,m)$，每次可以从 $(x,y)$ 走到 $(x+1,y)$ 或 $(x,y+1)$。 有 $k$ 个传送门，第 $i$ 个传送门在 $(x_i,y_i)$，碰到传送门就必须要立即移动到另一个传送门（不能原地传送）。 求有多少种恰好传送一次后到达终点的行走方案。 $n,m \\le 10^5,k \\le 2000$ 做法枚举传送的起点和终点是哪两个传送门，问题转化成： 有多少种方法从起点走到传送门 $i$ / 从传送门 $i$ 走到终点，中途不碰到任何其它的传送门。 考虑从起点走到传送门 $i$ 的情况，另一种同理。 设 $i$ 的答案是 $dp_i$，$cnt(a,b)$ 表示向 $x$ 方向走 $a$ 步，向 $y$ 方向走 $b$ 步的方案数。 易得 $cnt(a,b)=\\binom{a+b}{a}$。 如果不考虑 “中途不碰到任何其它的传送门” 这一条件，那么 $dp_i=cnt(x_i,y_i)$。 枚举第一个碰到的传送门 $j$，从起点走到 $j$ （中途不碰到任何其它的传送门）有 $dp_j$ 种方案，从 $j$ 走到 $i$（因为已经确定了第一个碰到的，所以后面就没有限制条件了）有 $cnt(x_i-x_j,y_i-y_j)$ 种方案，所以 $dp_i$ 要减去 $dp_j \\cdot cnt(x_i-x_j,y_i-y_j)$。 然后发现只有在 $x_j\\le x_i$ 且 $y_j \\le y_i$ 时这个转移才有效，所以把所有坐标按照 $x+y$ 从小到大排序，计算 $dp_i$ 时只要考虑所有 $j&lt;i$。 复杂度 $O(n^2)$。 代码123456789101112131415161718192021222324252627int n, m, r, c, a[20][20];vector&lt;int&gt;v;int cost1[20][20], cost2[20], dp[20][20], ans = MAXN;void solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; c; rep(i, n)rep(j, m)cin &gt;&gt; a[i][j]; repp(w, (1 &lt;&lt; m) - 1) { v.clear(); rep(i, m)if ((w &gt;&gt; i) &amp; 1)v.pb(i); if ((int)v.size() != c)continue; rep(i, n)forr(j, i + 1, n - 1) { cost1[i][j] = 0; rep(k, c)cost1[i][j] += abs(a[i][v[k]] - a[j][v[k]]); } rep(i, n) { cost2[i] = 0; rep(j, c - 1)cost2[i] += abs(a[i][v[j]] - a[i][v[j + 1]]); } init(dp, 63); rep(i, n) { dp[i][0] = 0, dp[i][1] = cost2[i]; forr(j, 2, i + 1)rep(k, i)dp[i][j] = min(dp[i][j], dp[k][j - 1] + cost1[k][i] + cost2[i]); ans = min(ans, dp[i][r]); } } cout &lt;&lt; ans;} 写在最后感觉这场比赛都是第一眼很吓人，仔细想想其实还好的题。 大家来了应该都能爆切吧。 QwQ","link":"/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F2022%E5%88%9D%E8%B5%9B%E6%B8%B8%E8%AE%B0/"},{"title":"斯涅尔定律最愚蠢的证法","text":"2022 年整的最后一个活。 问题平面直角坐标系上有两点 $S(0,h_1)$ 和 $T(w,h_2)$ 满足 $h_1&gt;0,h_2&lt;0$，一个动点 $P$ 从 $S$ 出发移动到 $T$。$P$ 在 $x$ 轴上方时的速度为 $v_1$，在 $x$ 轴下方时的速度为 $v_2$，求时间最短的路径。 斯涅尔定律：$\\dfrac{\\sin(\\theta_1)}{v_1}=\\dfrac{\\sin(\\theta_2)}{v_2}$ 证明显然，路径为两条线段组成的折线，转折点在 $x$ 轴上。 设折线与 $x$ 轴交点位于 $(0,x)$。 容易得出路径长度的函数 $f(x)$：$$f(x)=\\dfrac{\\sqrt{h_1^2+x^2}}{v}+\\dfrac{\\sqrt{h_2^2+(w-x)^2}}{v2}$$ 当取 $h_1=3,h_2=5,w=10,v_1=3,v_2=1$ 时，函数图像长这个样子： 发现它是一个单谷函数，它的最小值就是唯一的极小值。所以求导： $$f’(x)=\\dfrac{v_2x\\sqrt{(w-x)^2+h_2^2}-v_1(w-x)\\sqrt{x^2+h_1^2}}{v_1v_2\\sqrt{x^2+h_1^2}\\sqrt{(w-x)^2+h_2^2}}$$ 最小值点的导数为 $0$，所以得出： $$v_2x\\sqrt{(w-x)^2+h_2^2}=v_1(w-x)\\sqrt{x^2+h_1^2}$$ $$\\dfrac{x\\sqrt{(w-x)^2+h_2^2}}{(w-x)\\sqrt{x^2+h_1^2}}=\\dfrac{v_1}{v_2}$$ $$\\dfrac{x}{\\sqrt{x^2+h_1^2}}:\\dfrac{w-x}{\\sqrt{(w-x)^2+h_2^2}}=v_1:v_2$$ $$\\dfrac{SP}{SM}:\\dfrac{QT}{MT}=v_1:v_2$$ $$\\dfrac{\\sin(\\theta_1)}{v_1}=\\dfrac{\\sin(\\theta_2)}{v_2}$$ 证毕。","link":"/%E6%96%AF%E6%B6%85%E5%B0%94%E5%AE%9A%E5%BE%8B%E6%9C%80%E6%84%9A%E8%A0%A2%E7%9A%84%E8%AF%81%E6%B3%95/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","link":"/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"AtCoder","slug":"AtCoder","link":"/tags/AtCoder/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Pi节","slug":"Pi节","link":"/tags/Pi%E8%8A%82/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"二分图","slug":"二分图","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"FFT","slug":"FFT","link":"/tags/FFT/"},{"name":"POJ","slug":"POJ","link":"/tags/POJ/"},{"name":"URAL","slug":"URAL","link":"/tags/URAL/"},{"name":"USACO","slug":"USACO","link":"/tags/USACO/"},{"name":"SPOJ","slug":"SPOJ","link":"/tags/SPOJ/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"UVA","slug":"UVA","link":"/tags/UVA/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"百度之星","slug":"百度之星","link":"/tags/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F/"},{"name":"几何","slug":"几何","link":"/tags/%E5%87%A0%E4%BD%95/"},{"name":"微积分","slug":"微积分","link":"/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"categories":[{"name":"比赛笔记","slug":"比赛笔记","link":"/categories/%E6%AF%94%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"pages":[{"title":"","text":"404 Not Found window.game = new CatchTheCatGame({ w: 11, h: 11, r: 20, backgroundColor: 0xffffff, parent: 'catch-the-cat', statusBarAlign: 'center', credit: 'Reflective-FG\\'s Blog' });","link":"/404.html"},{"title":"","text":"dcdced80b2972b3b9f2a9df9ec152f26","link":"/baidu_verify_codeva-UYLWsifqNl.html"},{"title":"","text":"��#\u0000 \u0000Q\u0000C\u0000P\u0000l\u0000a\u0000y\u0000g\u0000r\u0000o\u0000u\u0000n\u0000d\u0000\u0000\u0000","link":"/README.html"},{"title":"","text":"!function(t){var e={};function n(o){if(e[o])return e[o].exports;var r=e[o]={i:o,l:!1,exports:{}};return t[o].call(r.exports,r,r.exports,n),r.l=!0,r.exports}n.m=t,n.c=e,n.d=function(t,e,o){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o})},n.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var r in t)n.d(o,r,function(e){return t[e]}.bind(null,r));return o},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p=\"\",n(n.s=3)}([function(t,e,n){\"use strict\";var o,r=this&&this.__extends||(o=function(t,e){return(o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(t,e)},function(t,e){function n(){this.constructor=t}o(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)});Object.defineProperty(e,\"__esModule\",{value:!0});var i,s=n(1),a=n(20),l=n(22),d=n(23),h=n(24),u=n(25),f=n(2),p=n(26),c=n(27);!function(t){t.PLAYING=\"playing\",t.WIN=\"win\",t.LOSE=\"lose\"}(i||(i={}));var k=function(t){function e(e,n,o){var r=t.call(this,{key:\"MainScene\"})||this;return r.w=e,r.h=n,r.r=o,r.dx=2*r.r,r.dy=r.r*Math.sqrt(3),r}return r(e,t),Object.defineProperty(e.prototype,\"blocks\",{get:function(){return this.data.get(\"blocks\")},set:function(t){this.data.set(\"blocks\",t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,\"blocksData\",{get:function(){var t=[];return this.blocks.forEach(function(e,n){t[n]=[],e.forEach(function(e,o){t[n][o]=e.isWall})}),t},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,\"cat\",{get:function(){return this.data.get(\"cat\")},set:function(t){this.data.set(\"cat\",t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,\"statusBar\",{get:function(){return this.data.get(\"status_bar\")},set:function(t){this.data.set(\"status_bar\",t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,\"creditText\",{get:function(){return this.data.get(\"credit_text\")},set:function(t){this.data.set(\"credit_text\",t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,\"state\",{get:function(){return this.data.get(\"state\")},set:function(t){switch(t){case i.PLAYING:break;case i.LOSE:this.setStatusText(f.default(\"猫已经跑到地图边缘了，你输了\"));break;case i.WIN:this.setStatusText(f.default(\"猫已经无路可走，你赢了\"));break;default:return}this.data.set(\"state\",t)},enumerable:!0,configurable:!0}),e.getNeighbours=function(t,e){var n,o,r,i,s={i:t-1,j:e},a={i:t+1,j:e};0==(1&e)?(n={i:t-1,j:e-1},o={i:t,j:e-1},r={i:t-1,j:e+1},i={i:t,j:e+1}):(n={i:t,j:e-1},o={i:t+1,j:e-1},r={i:t,j:e+1},i={i:t+1,j:e+1});var l=[];return l[0]=s,l[1]=n,l[2]=o,l[3]=a,l[4]=i,l[5]=r,l},e.prototype.preload=function(){var t=this.r/s.default.catStepLength;for(var e in s.default.textures)this.load.addFile(new c.default(this.load,e,s.default.textures[e],{scale:t}))},e.prototype.create=function(){this.createAnimations(),this.createBlocks(),this.createCat(),this.createStatusText(),this.createResetButton(),this.createCreditText(),this.reset(),this.game.solver&&(this.cat.solver=this.game.solver)},e.prototype.getPosition=function(t,e){return{x:3*this.r+(0==(1&e)?this.r:this.dx)+t*this.dx,y:3*this.r+this.r+e*this.dy}},e.prototype.getBlock=function(t,e){return t>=0&&t=0&&e","link":"/catch-the-cat.js"},{"title":"","text":"{\"companyName\":\"Quantum Realm Games\",\"productName\":\"Qute\",\"productVersion\":\"1.4\",\"dataUrl\":\"playground.data.unityweb\",\"asmCodeUrl\":\"playground.asm.code.unityweb\",\"asmMemoryUrl\":\"playground.asm.memory.unityweb\",\"asmFrameworkUrl\":\"playground.asm.framework.unityweb\",\"TOTAL_MEMORY\":268435456,\"graphicsAPI\":[\"WebGL 2.0\",\"WebGL 1.0\"],\"webglContextAttributes\":{\"preserveDrawingBuffer\":false},\"splashScreenStyle\":\"Dark\",\"backgroundColor\":\"#231F20\",\"cacheControl\":{\"default\":\"must-revalidate\"},\"developmentBuild\":false,\"multithreading\":false,\"unityVersion\":\"2019.4.18f1\"}","link":"/Build/playground.json"},{"title":"","text":"{\"m_buildTarget\":\"WebGL\",\"m_SettingsHash\":\"\",\"m_CatalogLocations\":[{\"m_Keys\":[\"AddressablesMainContentCatalog\"],\"m_InternalId\":\"{UnityEngine.AddressableAssets.Addressables.RuntimePath}/catalog.json\",\"m_Provider\":\"UnityEngine.AddressableAssets.ResourceProviders.ContentCatalogProvider\",\"m_Dependencies\":[],\"m_ResourceType\":{\"m_AssemblyName\":\"Unity.Addressables, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.AddressableAssets.ResourceLocators.ContentCatalogData\"}}],\"m_ProfileEvents\":false,\"m_LogResourceManagerExceptions\":true,\"m_ExtraInitializationData\":[],\"m_DisableCatalogUpdateOnStart\":false,\"m_IsLocalCatalogInBundle\":false,\"m_CertificateHandlerType\":{\"m_AssemblyName\":\"\",\"m_ClassName\":\"\"},\"m_AddressablesVersion\":\"1.16.19\",\"m_maxConcurrentWebRequests\":500}","link":"/StreamingAssets/aa/settings.json"},{"title":"","text":"{\"m_LocatorId\":\"AddressablesMainContentCatalog\",\"m_InstanceProviderData\":{\"m_Id\":\"UnityEngine.ResourceManagement.ResourceProviders.InstanceProvider\",\"m_ObjectType\":{\"m_AssemblyName\":\"Unity.ResourceManager, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.ResourceManagement.ResourceProviders.InstanceProvider\"},\"m_Data\":\"\"},\"m_SceneProviderData\":{\"m_Id\":\"UnityEngine.ResourceManagement.ResourceProviders.SceneProvider\",\"m_ObjectType\":{\"m_AssemblyName\":\"Unity.ResourceManager, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.ResourceManagement.ResourceProviders.SceneProvider\"},\"m_Data\":\"\"},\"m_ResourceProviderData\":[{\"m_Id\":\"UnityEngine.ResourceManagement.ResourceProviders.LegacyResourcesProvider\",\"m_ObjectType\":{\"m_AssemblyName\":\"Unity.ResourceManager, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.ResourceManagement.ResourceProviders.LegacyResourcesProvider\"},\"m_Data\":\"\"},{\"m_Id\":\"UnityEngine.ResourceManagement.ResourceProviders.AssetBundleProvider\",\"m_ObjectType\":{\"m_AssemblyName\":\"Unity.ResourceManager, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.ResourceManagement.ResourceProviders.AssetBundleProvider\"},\"m_Data\":\"\"},{\"m_Id\":\"UnityEngine.ResourceManagement.ResourceProviders.BundledAssetProvider\",\"m_ObjectType\":{\"m_AssemblyName\":\"Unity.ResourceManager, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.ResourceManagement.ResourceProviders.BundledAssetProvider\"},\"m_Data\":\"\"},{\"m_Id\":\"UnityEngine.ResourceManagement.ResourceProviders.LegacyResourcesProvider\",\"m_ObjectType\":{\"m_AssemblyName\":\"Unity.ResourceManager, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.ResourceManagement.ResourceProviders.LegacyResourcesProvider\"},\"m_Data\":\"\"},{\"m_Id\":\"UnityEngine.ResourceManagement.ResourceProviders.BundledAssetProvider\",\"m_ObjectType\":{\"m_AssemblyName\":\"Unity.ResourceManager, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.ResourceManagement.ResourceProviders.BundledAssetProvider\"},\"m_Data\":\"\"}],\"m_ProviderIds\":[\"UnityEngine.ResourceManagement.ResourceProviders.LegacyResourcesProvider\",\"\",\"UnityEngine.ResourceManagement.ResourceProviders.AssetBundleProvider\",\"UnityEngine.ResourceManagement.ResourceProviders.BundledAssetProvider\"],\"m_InternalIds\":[\"BillingMode\",\"Main\",\"Paths\",\"banner\",\"LineBreaking Following Characters\",\"LineBreaking Leading Characters\",\"TMP Settings\",\"Fonts & Materials/LiberationSans SDF - Drop Shadow\",\"Fonts & Materials/LiberationSans SDF - Fallback\",\"Fonts & Materials/LiberationSans SDF - Outline\",\"Fonts & Materials/LiberationSans SDF\",\"Shaders/TMP_Bitmap-Custom-Atlas\",\"Shaders/TMP_Bitmap-Mobile\",\"Shaders/TMP_Bitmap\",\"Shaders/TMP_SDF Overlay\",\"Shaders/TMP_SDF-Mobile Masking\",\"Shaders/TMP_SDF-Mobile Overlay\",\"Shaders/TMP_SDF-Mobile\",\"Shaders/TMP_SDF-Surface-Mobile\",\"Shaders/TMP_SDF-Surface\",\"Shaders/TMP_SDF\",\"Shaders/TMP_Sprite\",\"Sprite Assets/EmojiOne\",\"Style Sheets/Default Style Sheet\",\"xnode_dot\",\"xnode_dot_outer\",\"xnode_node\",\"xnode_node_highlight\",\"xnode_node_workfile\",\"ScriptTemplates/xNode_NodeGraphTemplate.cs\",\"ScriptTemplates/xNode_NodeTemplate.cs\",\"Styles/CollabHistoryCommon\",\"Styles/CollabHistoryDark\",\"Styles/CollabHistoryLight\",\"blue\",\"green\",\"pink\",\"yellow\",\"personal/actionTreeBackground\",\"personal/actionTreeBackgroundWithoutBorder\",\"personal/foldoutBackground\",\"personal/propertiesBackground\",\"pro/actionTreeBackground\",\"pro/actionTreeBackgroundWithoutBorder\",\"pro/foldoutBackground\",\"pro/propertiesBackground\",\"consola\",\"DownArrow\",\"Reset\",\"UpArrow\",\"Shaders/SoftMaskShader\",\"Shaders/UI Particle Add\",\"Shaders/UI Particle AddMultiply\",\"Shaders/UI Particle AddSmooth\",\"Shaders/UI Particle Alpha Blend\",\"Shaders/UI Particle Blend\",\"Shaders/UI Particle Multiply\",\"Shaders/UI Particle MultiplyDouble\",\"Shaders/UI Particle Premultiply Blend\",\"Shaders/UI Particle VertexLit Blended\",\"Shaders/UIAdditive\",\"Shaders/UIImageCrop\",\"Shaders/UILinearDodge\",\"Shaders/UIMultiply\",\"Shaders/UIParticleHidden\",\"Shaders/UIScreen\",\"Shaders/UISoftAdditive\",\"Scenes/ChatTutorial\",\"{UnityEngine.AddressableAssets.Addressables.RuntimePath}/WebGL/defaultlocalgroup_assets_all_1cca58f01bded360aff975f2c0dc4530.bundle\",\"{UnityEngine.AddressableAssets.Addressables.RuntimePath}/WebGL/board_assets_all_baef8c58f643aff7fd48bf2c39f49a3b.bundle\",\"Assets/AddressableAssets/Audio/Audio-Temp/Minimal UI Sounds/Spacey Click_Minimal UI Sounds.wav\",\"Assets/AddressableAssets/Audio/SFX/Button_Click_1.wav\",\"Assets/AddressableAssets/Audio/Music/QC Gameplay.wav\",\"Assets/AddressableAssets/Audio/SFX/Board Assemble.wav\",\"Assets/AddressableAssets/Audio/SFX/Defeat.wav\",\"Assets/AddressableAssets/Audio/SFX/Time_LowWarning.wav\",\"Assets/AddressableAssets/Audio/SFX/Victory.wav\",\"Assets/AddressableAssets/Audio/SFX/YourTurn.wav\",\"Assets/AddressableAssets/Audio/SFX/Message_Recieved.wav\"],\"m_KeyDataString\":\"nQAAAAALAAAAQmlsbGluZ01vZGUAIAAAADcyZGU0Y2QzZGI1NjFiZTRhYTRhNzBjZjlmYWFhMzE4AAQAAABNYWluACAAAAAxMzYyNzAyNTFhYTQ0ZTc0Yzg5OTUzZjBkMDUzMWIxYQAFAAAAUGF0aHMAIAAAAGRjZTdhYjcxYWIxODFlODQyYWFjMzU5YTg5MjM1OWRmAAYAAABiYW5uZXIAIAAAAGVmOGIyNWQ3MmQ2NTVlYTQzYTUxNmRkZmRhOTE1MjU0ACEAAABMaW5lQnJlYWtpbmcgRm9sbG93aW5nIENoYXJhY3RlcnMAIAAAAGZhZGU0MmU4YmM3MTRiMDE4ZmFjNTEzYzA0M2QzMjNiAB8AAABMaW5lQnJlYWtpbmcgTGVhZGluZyBDaGFyYWN0ZXJzACAAAABkODJjMWIzMWM3ZTc0MjM5YmZmMTIyMDU4NTcwN2QyYgAMAAAAVE1QIFNldHRpbmdzACAAAAAzZjViNWRmZjY3YTk0MjI4OWE5ZGVmYTQxNmIyMDZmMwAyAAAARm9udHMgJiBNYXRlcmlhbHMvTGliZXJhdGlvblNhbnMgU0RGIC0gRHJvcCBTaGFkb3cAIAAAAGU3M2E1OGY2ZTI3OTRhZTdiMWI3ZTUwYjdmYjgxMWIwAC8AAABGb250cyAmIE1hdGVyaWFscy9MaWJlcmF0aW9uU2FucyBTREYgLSBGYWxsYmFjawAgAAAAMmU0OThkMWM4MDk0OTEwNDc5ZGMzZTFiNzY4MzA2YTQALgAAAEZvbnRzICYgTWF0ZXJpYWxzL0xpYmVyYXRpb25TYW5zIFNERiAtIE91dGxpbmUAIAAAADc5NDU5ZWZlYzE3YTRkMDBhMzIxYmRjYzI3YmJjMzg1ACQAAABGb250cyAmIE1hdGVyaWFscy9MaWJlcmF0aW9uU2FucyBTREYAIAAAADhmNTg2Mzc4YjRlMTQ0YTk4NTFlN2IzNGQ5Yjc0OGVlAB8AAABTaGFkZXJzL1RNUF9CaXRtYXAtQ3VzdG9tLUF0bGFzACAAAAA0OGJiNWY1NWQ4NjcwZTM0OWI2ZTYxNDkxM2Y5ZDkxMAAZAAAAU2hhZGVycy9UTVBfQml0bWFwLU1vYmlsZQAgAAAAMWUzYjA1N2FmMjQyNDk3NDhmZjg3M2JlN2ZhZmVlNDcAEgAAAFNoYWRlcnMvVE1QX0JpdG1hcAAgAAAAMTI4ZTk4N2Q1NjdkNGUyYzgyNGQ3NTQyMjNiM2YzYjAAFwAAAFNoYWRlcnMvVE1QX1NERiBPdmVybGF5ACAAAABkZDg5Y2Y1YjkyNDY0MTZmODQ2MTBhMDA2ZjkxNmFmNwAeAAAAU2hhZGVycy9UTVBfU0RGLU1vYmlsZSBNYXNraW5nACAAAABiYzFlZGUzOWJmMzY0M2VlOGU0OTM3MjBlNDI1OTc5MQAeAAAAU2hhZGVycy9UTVBfU0RGLU1vYmlsZSBPdmVybGF5ACAAAABhMDJhN2Q4YzIzNzU0NGYxOTYyNzMyYjU1YTlhZWJmMQAWAAAAU2hhZGVycy9UTVBfU0RGLU1vYmlsZQAgAAAAZmUzOTNhY2U5YjM1NDM3NWE5Y2IxNGNkYmJjMjhiZTQAHgAAAFNoYWRlcnMvVE1QX1NERi1TdXJmYWNlLU1vYmlsZQAgAAAAODUxODdjMjE0OWM1NDljNWIzM2YwY2RiMDI4MzZiMTcAFwAAAFNoYWRlcnMvVE1QX1NERi1TdXJmYWNlACAAAABmN2FkYTBhZjRmMTc0ZjA2OTRjYTZhNDg3YjhmNTQzZAAPAAAAU2hhZGVycy9UTVBfU0RGACAAAAA2OGU2ZGIyZWJkYzI0Zjk1OTU4ZmFlYzJiZTU1NThkNgASAAAAU2hhZGVycy9UTVBfU3ByaXRlACAAAABjZjgxYzg1Zjk1ZmU0N2UxYTI3ZjZhZTQ2MGNmMTgyYwAWAAAAU3ByaXRlIEFzc2V0cy9FbW9qaU9uZQAgAAAAYzQxMDA1YzEyOWJhNGQ2NjkxMWI3NTIyOWZkNzBiNDUAIAAAAFN0eWxlIFNoZWV0cy9EZWZhdWx0IFN0eWxlIFNoZWV0ACAAAABmOTUyYzA4MmNiMDM0NTFkYWVkM2VlOTY4YWM2YzYzZQAJAAAAeG5vZGVfZG90ACAAAAA3NWExZmUwYjEwMjIyNmE0MTg0ODZlZDgyM2M5YTdmYgAPAAAAeG5vZGVfZG90X291dGVyACAAAAA0MzRjYThiNGJkZmE1NTc0YWJiMDAwMmJiYzliNjVhZAAKAAAAeG5vZGVfbm9kZQAgAAAAMmZlYTFkY2IyNDkzNWVmNGNhNTE0ZDUzNGViNmFhM2QAFAAAAHhub2RlX25vZGVfaGlnaGxpZ2h0ACAAAAAyYWIyYjkyZDdlMTc3MWI0N2JiYTBhNDZhNmYwZjZkNQATAAAAeG5vZGVfbm9kZV93b3JrZmlsZQAgAAAAMjI2N2VmYTZlMWUzNDkzNDhhZTBiMjhmYjY1OWE2ZTIAKgAAAFNjcmlwdFRlbXBsYXRlcy94Tm9kZV9Ob2RlR3JhcGhUZW1wbGF0ZS5jcwAgAAAAODE2NTc2N2Y2NGRhN2Q5NGU5MjVmNjFhMzhkYTY2OGMAJQAAAFNjcmlwdFRlbXBsYXRlcy94Tm9kZV9Ob2RlVGVtcGxhdGUuY3MAIAAAADg1ZjZmNTcwNjAwYTFhNDRkOGU3MzRjYjExMWE4Yjg5ABoAAABTdHlsZXMvQ29sbGFiSGlzdG9yeUNvbW1vbgAgAAAAM2EyZDk0Yzg5Nzc5ODRiNjc5ODRjYWVmZjlmYTY2NmUAGAAAAFN0eWxlcy9Db2xsYWJIaXN0b3J5RGFyawAgAAAANzBkNGQ3NWEyODc3MjQzNzU4YjA3NTBjYmM3NWI2ZWIAGQAAAFN0eWxlcy9Db2xsYWJIaXN0b3J5TGlnaHQAIAAAAGI1MmJkZTI2YTgzNTY0OTYwYmNiOTAyMTdmNzJiOTEwAAQAAABibHVlACAAAAAzM2YzMjE0MmMyYzJkNDY2MmJlNWY1Mjc0ZGIyNzE1OAAFAAAAZ3JlZW4AIAAAAGZmZWJhOTM2MzdlNjU0ZGU2YTU5MDZiNDg1MjBkYzk0AAQAAABwaW5rACAAAABkN2IxNDQzMjM5ODRkNDI5ODkyNGM2NWVkMDcxZGVhMQAGAAAAeWVsbG93ACAAAAA0N2NmNTA2YjQyMTkzNDM1MTkwODNmZTFjMGI4ZmM5YwAdAAAAcGVyc29uYWwvYWN0aW9uVHJlZUJhY2tncm91bmQAIAAAAGNlNWYxMWNkOTkzMjg0YzRmOWM1NGY4NTRiZGM4YzljACoAAABwZXJzb25hbC9hY3Rpb25UcmVlQmFja2dyb3VuZFdpdGhvdXRCb3JkZXIAIAAAAGNmNjMyZWQ4MGJmMWY0NmM5ODBkZTZiMWI4YjkwM2VmABoAAABwZXJzb25hbC9mb2xkb3V0QmFja2dyb3VuZAAgAAAANWFiNjk3MDRhYTQ5ODRiNDliYzQyNmRhNzJmYWJiZWQAHQAAAHBlcnNvbmFsL3Byb3BlcnRpZXNCYWNrZ3JvdW5kACAAAABhYTRjMjM2MGY5MTBkNDZmNDk3Zjc1YjRiNjY3NzM1OAAYAAAAcHJvL2FjdGlvblRyZWVCYWNrZ3JvdW5kACAAAABjNGI2NmUzMTM5NWM1NDA4N2EyZmJjMTNhZTdlMGYzYwAlAAAAcHJvL2FjdGlvblRyZWVCYWNrZ3JvdW5kV2l0aG91dEJvcmRlcgAgAAAAOTQzZGVhYWVlOWM5MzQ3ZTBhNDU1YWEyMDg1MjZjNDIAFQAAAHByby9mb2xkb3V0QmFja2dyb3VuZAAgAAAAYzA5OTZiYzI5MGZmNzRiZjQ4MzRmNGE4YjdkYzhjM2UAGAAAAHByby9wcm9wZXJ0aWVzQmFja2dyb3VuZAAgAAAAYjAyZTNmMGMwNzk4YTRmMTc4OWE4OWE3Njk3NjYwYmUABwAAAGNvbnNvbGEAIAAAAGI4YWY1ODgyMGY2OWI0NzRlOGY2M2RjNDBhNzAyZmJjAAkAAABEb3duQXJyb3cAIAAAADNlMzVlNTYzMzBmM2RiYTQyYWY5MjQ0YTJhNWU3NWZmAAUAAABSZXNldAAgAAAAZmE0MjU0ZGNjYWExYmZkNDhiN2EzNzI4YTQwYTU3YWYABwAAAFVwQXJyb3cAIAAAADFlYTdlMDQ2MmQxZjY3ODQ1YWYzMDkwYWU4NWI5MWNiABYAAABTaGFkZXJzL1NvZnRNYXNrU2hhZGVyACAAAAA5NDdhZmFlNGQzNmYxMjc0ZWEyZTQwOTgyNjJjZWVmNgAXAAAAU2hhZGVycy9VSSBQYXJ0aWNsZSBBZGQAIAAAAGUwNjQxMDQ3ODhkOTRiMzQ5YWIxMzE0MWEzMGI1NjYwAB8AAABTaGFkZXJzL1VJIFBhcnRpY2xlIEFkZE11bHRpcGx5ACAAAAAwODhiYmZkOTIyMmVlMDQ0Y2I0ZTQ2OTkzMzZlOWZmMQAdAAAAU2hhZGVycy9VSSBQYXJ0aWNsZSBBZGRTbW9vdGgAIAAAADRjMjIxMWIxMjAxNjhlNDRkYjRhM2E4NDE3MDEzNjE1AB8AAABTaGFkZXJzL1VJIFBhcnRpY2xlIEFscGhhIEJsZW5kACAAAABjM2Q3ZDhkNzFhOTEwNzE0NjlhZDcwMTllNzc4NjRkNgAZAAAAU2hhZGVycy9VSSBQYXJ0aWNsZSBCbGVuZAAgAAAAOThmZWQ1YmE1MDBhOWEwNGE4MDMyNTI2NmI5OTExYmIAHAAAAFNoYWRlcnMvVUkgUGFydGljbGUgTXVsdGlwbHkAIAAAADMyMGY2YmI3YmRlMzY5YjRhODVjOWQ4OWE5YmE1MjY4ACIAAABTaGFkZXJzL1VJIFBhcnRpY2xlIE11bHRpcGx5RG91YmxlACAAAAAwNzY1ZWNlZjU4ODMzYzM0MjkzNDZhMWZlZTQ1ZTRlMAAlAAAAU2hhZGVycy9VSSBQYXJ0aWNsZSBQcmVtdWx0aXBseSBCbGVuZAAgAAAAMDU5NmE2ODM4ZDc4ZjYyNDM5N2I2NDI4MTdjZjIwYmMAJQAAAFNoYWRlcnMvVUkgUGFydGljbGUgVmVydGV4TGl0IEJsZW5kZWQAIAAAADY1YmJiNzg5YWRhNThhYjQ0YWFlZGJlMDk2ODdmMDg5ABIAAABTaGFkZXJzL1VJQWRkaXRpdmUAIAAAADIwZmI1ZmEwOWQ0Njc1YTRlOTQzMTRhMjI4NzYzYzIzABMAAABTaGFkZXJzL1VJSW1hZ2VDcm9wACAAAABjY2Y1YTBjOGY4N2QzYzU0N2FmZjNkYWVjYjMxNjRhNAAVAAAAU2hhZGVycy9VSUxpbmVhckRvZGdlACAAAABjM2MzYWY1OTc5MGNmMzc0OWJhNDlmZTFjODM4Yzk0ZQASAAAAU2hhZGVycy9VSU11bHRpcGx5ACAAAABkMjg3ODcyY2E4ZmQ3NzY0MThjMjhkMzMyZGY1ODVjMwAYAAAAU2hhZGVycy9VSVBhcnRpY2xlSGlkZGVuACAAAABjZjczYTBhNGI1ZWE4OTk0ZjkxNmNkMThhOTdjNTY0YgAQAAAAU2hhZGVycy9VSVNjcmVlbgAgAAAAMjI3YWMyMWY3NzYzYzAwNDg5Y2M0NThlMzkzOGUzMjYAFgAAAFNoYWRlcnMvVUlTb2Z0QWRkaXRpdmUAIAAAAGZiMmUxNmEzZDEyODAzMzRhOWUwNTM5NGUxODkwZjA5AAwAAABDaGF0VHV0b3JpYWwAIAAAAGE1MzNmODBiOWMzZDFmNzQ3OTUxNDBiNGJlMDE3MTU2BAAAAAAARAAAAGRlZmF1bHRsb2NhbGdyb3VwX2Fzc2V0c19hbGxfMWNjYTU4ZjAxYmRlZDM2MGFmZjk3NWYyYzBkYzQ1MzAuYnVuZGxlADgAAABib2FyZF9hc3NldHNfYWxsX2JhZWY4YzU4ZjY0M2FmZjdmZDQ4YmYyYzM5ZjQ5YTNiLmJ1bmRsZQBaAAAAQXNzZXRzL0FkZHJlc3NhYmxlQXNzZXRzL0F1ZGlvL0F1ZGlvLVRlbXAvTWluaW1hbCBVSSBTb3VuZHMvU3BhY2V5IENsaWNrX01pbmltYWwgVUkgU291bmRzACAAAAA0ZmIxMzVkM2M0NWVlNzM0M2JhMzQxMjJmOGFkYzM1ZgAxAAAAQXNzZXRzL0FkZHJlc3NhYmxlQXNzZXRzL0F1ZGlvL1NGWC9CdXR0b25fQ2xpY2tfMQAgAAAAY2FjNDQwZGVhYjViOTlhNDk4YzI3YmY5MmJjYzExZWIAMAAAAEFzc2V0cy9BZGRyZXNzYWJsZUFzc2V0cy9BdWRpby9NdXNpYy9RQyBHYW1lcGxheQAgAAAAMmJhODk4YjZlN2UxNWU4NDdiYmNmZDhmOTJiNzA3NmEAMQAAAEFzc2V0cy9BZGRyZXNzYWJsZUFzc2V0cy9BdWRpby9TRlgvQm9hcmQgQXNzZW1ibGUAIAAAAGM4ZDU4ODlkNjBjYzBiYTQzYjAyMzc4MGM2YWVmMjRmACkAAABBc3NldHMvQWRkcmVzc2FibGVBc3NldHMvQXVkaW8vU0ZYL0RlZmVhdAAgAAAAZjMxZGNiMDQ1MTdmYmUyNDJhNzU4NTg5MTE0ZWU2ZmQAMgAAAEFzc2V0cy9BZGRyZXNzYWJsZUFzc2V0cy9BdWRpby9TRlgvVGltZV9Mb3dXYXJuaW5nACAAAAA5ZjVjNTg3MTBhM2VlMDI0ODg2ZDBhM2RlMzIxMDMzMQAqAAAAQXNzZXRzL0FkZHJlc3NhYmxlQXNzZXRzL0F1ZGlvL1NGWC9WaWN0b3J5ACAAAAA2NWNjZDRmMDQ0Y2E5MGQ0MmFlM2JmYWM2NDljMGI2NQArAAAAQXNzZXRzL0FkZHJlc3NhYmxlQXNzZXRzL0F1ZGlvL1NGWC9Zb3VyVHVybgAgAAAAYWJiZDVkOTk2ZmNmMWQyNDA4NjQ3ZmY3ZjMzZTA4ODQAMwAAAEFzc2V0cy9BZGRyZXNzYWJsZUFzc2V0cy9BdWRpby9TRlgvTWVzc2FnZV9SZWNpZXZlZAAgAAAANGYyNGYzYzJmOTIwMTU4NGFiNzlmNmFmNDUyMzczZjU=\",\"m_BucketDataString\":\"nQAAAAQAAAABAAAAAAAAABQAAAABAAAAAAAAADkAAAACAAAAAQAAAAIAAABCAAAAAgAAAAEAAAACAAAAZwAAAAEAAAADAAAAcQAAAAEAAAADAAAAlgAAAAEAAAAEAAAAoQAAAAEAAAAEAAAAxgAAAAEAAAAFAAAA7AAAAAEAAAAFAAAAEQEAAAEAAAAGAAAANQEAAAEAAAAGAAAAWgEAAAEAAAAHAAAAawEAAAEAAAAHAAAAkAEAAAEAAAAIAAAAxwEAAAEAAAAIAAAA7AEAAAMAAAAJAAAACgAAAAsAAAAgAgAAAwAAAAkAAAAKAAAACwAAAEUCAAABAAAADAAAAHgCAAABAAAADAAAAJ0CAAADAAAADQAAAA4AAAAPAAAAxgIAAAMAAAANAAAADgAAAA8AAADrAgAAAQAAABAAAAAPAwAAAQAAABAAAAA0AwAAAQAAABEAAABSAwAAAQAAABEAAAB3AwAAAQAAABIAAACOAwAAAQAAABIAAACzAwAAAQAAABMAAADPAwAAAQAAABMAAAD0AwAAAQAAABQAAAAXBAAAAQAAABQAAAA8BAAAAQAAABUAAABfBAAAAQAAABUAAACEBAAAAQAAABYAAACfBAAAAQAAABYAAADEBAAAAQAAABcAAADnBAAAAQAAABcAAAAMBQAAAQAAABgAAAAoBQAAAQAAABgAAABNBQAAAQAAABkAAABhBQAAAQAAABkAAACGBQAAAQAAABoAAACdBQAAAQAAABoAAADCBQAAAgAAABsAAAAcAAAA3QUAAAIAAAAbAAAAHAAAAAIGAAABAAAAHQAAACcGAAABAAAAHQAAAEwGAAABAAAAHgAAAFoGAAABAAAAHgAAAH8GAAABAAAAHwAAAJMGAAABAAAAHwAAALgGAAABAAAAIAAAAMcGAAABAAAAIAAAAOwGAAABAAAAIQAAAAUHAAABAAAAIQAAACoHAAABAAAAIgAAAEIHAAABAAAAIgAAAGcHAAABAAAAIwAAAJYHAAABAAAAIwAAALsHAAABAAAAJAAAAOUHAAABAAAAJAAAAAoIAAABAAAAJQAAACkIAAABAAAAJQAAAE4IAAABAAAAJgAAAGsIAAABAAAAJgAAAJAIAAABAAAAJwAAAK4IAAABAAAAJwAAANMIAAABAAAAKAAAANwIAAABAAAAKAAAAAEJAAABAAAAKQAAAAsJAAABAAAAKQAAADAJAAABAAAAKgAAADkJAAABAAAAKgAAAF4JAAABAAAAKwAAAGkJAAABAAAAKwAAAI4JAAABAAAALAAAALAJAAABAAAALAAAANUJAAABAAAALQAAAAQKAAABAAAALQAAACkKAAABAAAALgAAAEgKAAABAAAALgAAAG0KAAABAAAALwAAAI8KAAABAAAALwAAALQKAAABAAAAMAAAANEKAAABAAAAMAAAAPYKAAABAAAAMQAAACALAAABAAAAMQAAAEULAAABAAAAMgAAAF8LAAABAAAAMgAAAIQLAAABAAAAMwAAAKELAAABAAAAMwAAAMYLAAADAAAANAAAADUAAAA2AAAA0gsAAAMAAAA0AAAANQAAADYAAAD3CwAAAQAAADcAAAAFDAAAAQAAADcAAAAqDAAAAQAAADgAAAA0DAAAAQAAADgAAABZDAAAAQAAADkAAABlDAAAAQAAADkAAACKDAAAAQAAADoAAAClDAAAAQAAADoAAADKDAAAAQAAADsAAADmDAAAAQAAADsAAAALDQAAAQAAADwAAAAvDQAAAQAAADwAAABUDQAAAQAAAD0AAAB2DQAAAQAAAD0AAACbDQAAAQAAAD4AAAC/DQAAAQAAAD4AAADkDQAAAQAAAD8AAAACDgAAAQAAAD8AAAAnDgAAAQAAAEAAAABIDgAAAQAAAEAAAABtDgAAAQAAAEEAAACUDgAAAQAAAEEAAAC5DgAAAQAAAEIAAADjDgAAAQAAAEIAAAAIDwAAAQAAAEMAAAAyDwAAAQAAAEMAAABXDwAAAQAAAEQAAABuDwAAAQAAAEQAAACTDwAAAQAAAEUAAACrDwAAAQAAAEUAAADQDwAAAQAAAEYAAADqDwAAAQAAAEYAAAAPEAAAAQAAAEcAAAAmEAAAAQAAAEcAAABLEAAAAQAAAEgAAABoEAAAAQAAAEgAAACNEAAAAQAAAEkAAACiEAAAAQAAAEkAAADHEAAAAQAAAEoAAADiEAAAAQAAAEoAAAAHEQAAAQAAAEsAAAAYEQAAAQAAAEsAAAA9EQAAAQAAAEsAAABCEQAAAQAAAEwAAACLEQAAAQAAAE0AAADIEQAAAQAAAE4AAAAnEgAAAQAAAE4AAABMEgAAAQAAAE8AAACCEgAAAQAAAE8AAACnEgAAAQAAAFAAAADcEgAAAQAAAFAAAAABEwAAAQAAAFEAAAA3EwAAAQAAAFEAAABcEwAAAQAAAFIAAACKEwAAAQAAAFIAAACvEwAAAQAAAFMAAADmEwAAAQAAAFMAAAALFAAAAQAAAFQAAAA6FAAAAQAAAFQAAABfFAAAAQAAAFUAAACPFAAAAQAAAFUAAAC0FAAAAQAAAFYAAADsFAAAAQAAAFYAAAA=\",\"m_EntryDataString\":\"VwAAAAAAAAAAAAAA/////wAAAAD/////AAAAAAAAAAABAAAAAAAAAP////8AAAAA/////wIAAAABAAAAAQAAAAAAAAD/////AAAAAP////8CAAAAAgAAAAIAAAAAAAAA/////wAAAAD/////BAAAAAMAAAADAAAAAAAAAP////8AAAAA/////wYAAAAEAAAABAAAAAAAAAD/////AAAAAP////8IAAAAAAAAAAUAAAAAAAAA/////wAAAAD/////CgAAAAAAAAAGAAAAAAAAAP////8AAAAA/////wwAAAAFAAAABwAAAAAAAAD/////AAAAAP////8OAAAABgAAAAgAAAAAAAAA/////wAAAAD/////EAAAAAcAAAAIAAAAAAAAAP////8AAAAA/////xAAAAAGAAAACAAAAAAAAAD/////AAAAAP////8QAAAABAAAAAkAAAAAAAAA/////wAAAAD/////EgAAAAYAAAAKAAAAAAAAAP////8AAAAA/////xQAAAAHAAAACgAAAAAAAAD/////AAAAAP////8UAAAABgAAAAoAAAAAAAAA/////wAAAAD/////FAAAAAQAAAALAAAAAAAAAP////8AAAAA/////xYAAAAIAAAADAAAAAAAAAD/////AAAAAP////8YAAAACAAAAA0AAAAAAAAA/////wAAAAD/////GgAAAAgAAAAOAAAAAAAAAP////8AAAAA/////xwAAAAIAAAADwAAAAAAAAD/////AAAAAP////8eAAAACAAAABAAAAAAAAAA/////wAAAAD/////IAAAAAgAAAARAAAAAAAAAP////8AAAAA/////yIAAAAIAAAAEgAAAAAAAAD/////AAAAAP////8kAAAACAAAABMAAAAAAAAA/////wAAAAD/////JgAAAAgAAAAUAAAAAAAAAP////8AAAAA/////ygAAAAIAAAAFQAAAAAAAAD/////AAAAAP////8qAAAACAAAABYAAAAAAAAA/////wAAAAD/////LAAAAAkAAAAWAAAAAAAAAP////8AAAAA/////ywAAAAGAAAAFwAAAAAAAAD/////AAAAAP////8uAAAACgAAABgAAAAAAAAA/////wAAAAD/////MAAAAAQAAAAZAAAAAAAAAP////8AAAAA/////zIAAAAEAAAAGgAAAAAAAAD/////AAAAAP////80AAAABAAAABsAAAAAAAAA/////wAAAAD/////NgAAAAQAAAAcAAAAAAAAAP////8AAAAA/////zgAAAAEAAAAHQAAAAAAAAD/////AAAAAP////86AAAAAAAAAB4AAAAAAAAA/////wAAAAD/////PAAAAAAAAAAfAAAAAAAAAP////8AAAAA/////z4AAAALAAAAIAAAAAAAAAD/////AAAAAP////9AAAAACwAAACEAAAAAAAAA/////wAAAAD/////QgAAAAsAAAAiAAAAAAAAAP////8AAAAA/////0QAAAAEAAAAIwAAAAAAAAD/////AAAAAP////9GAAAABAAAACQAAAAAAAAA/////wAAAAD/////SAAAAAQAAAAlAAAAAAAAAP////8AAAAA/////0oAAAAEAAAAJgAAAAAAAAD/////AAAAAP////9MAAAABAAAACcAAAAAAAAA/////wAAAAD/////TgAAAAQAAAAoAAAAAAAAAP////8AAAAA/////1AAAAAEAAAAKQAAAAAAAAD/////AAAAAP////9SAAAABAAAACoAAAAAAAAA/////wAAAAD/////VAAAAAQAAAArAAAAAAAAAP////8AAAAA/////1YAAAAEAAAALAAAAAAAAAD/////AAAAAP////9YAAAABAAAAC0AAAAAAAAA/////wAAAAD/////WgAAAAQAAAAuAAAAAAAAAP////8AAAAA/////1wAAAAMAAAALgAAAAAAAAD/////AAAAAP////9cAAAABgAAAC4AAAAAAAAA/////wAAAAD/////XAAAAAQAAAAvAAAAAAAAAP////8AAAAA/////14AAAAEAAAAMAAAAAAAAAD/////AAAAAP////9gAAAABAAAADEAAAAAAAAA/////wAAAAD/////YgAAAAQAAAAyAAAAAAAAAP////8AAAAA/////2QAAAAIAAAAMwAAAAAAAAD/////AAAAAP////9mAAAACAAAADQAAAAAAAAA/////wAAAAD/////aAAAAAgAAAA1AAAAAAAAAP////8AAAAA/////2oAAAAIAAAANgAAAAAAAAD/////AAAAAP////9sAAAACAAAADcAAAAAAAAA/////wAAAAD/////bgAAAAgAAAA4AAAAAAAAAP////8AAAAA/////3AAAAAIAAAAOQAAAAAAAAD/////AAAAAP////9yAAAACAAAADoAAAAAAAAA/////wAAAAD/////dAAAAAgAAAA7AAAAAAAAAP////8AAAAA/////3YAAAAIAAAAPAAAAAAAAAD/////AAAAAP////94AAAACAAAAD0AAAAAAAAA/////wAAAAD/////egAAAAgAAAA+AAAAAAAAAP////8AAAAA/////3wAAAAIAAAAPwAAAAAAAAD/////AAAAAP////9+AAAACAAAAEAAAAAAAAAA/////wAAAAD/////gAAAAAgAAABBAAAAAAAAAP////8AAAAA/////4IAAAAIAAAAQgAAAAAAAAD/////AAAAAP////+EAAAACAAAAEMAAAABAAAA/////wAAAAD/////hgAAAA0AAABEAAAAAgAAAP////8AAAAAAAAAAIkAAAAOAAAARQAAAAIAAAD/////AAAAAIcCAACKAAAADgAAAEYAAAADAAAAiQAAAP7G+oH/////iwAAAA8AAABHAAAAAwAAAIkAAAD+xvqB/////40AAAAPAAAASAAAAAMAAACKAAAA6tHK1v////+PAAAADwAAAEkAAAADAAAAigAAAOrRytb/////kQAAAA8AAABKAAAAAwAAAIoAAADq0crW/////5MAAAAPAAAASwAAAAMAAACKAAAA6tHK1v////+VAAAADwAAAEwAAAADAAAAigAAAOrRytb/////lwAAAA8AAABNAAAAAwAAAIoAAADq0crW/////5kAAAAPAAAATgAAAAMAAACKAAAA6tHK1v////+bAAAADwAAAA==\",\"m_ExtraDataString\":\"B0xVbml0eS5SZXNvdXJjZU1hbmFnZXIsIFZlcnNpb249MC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1udWxsSlVuaXR5RW5naW5lLlJlc291cmNlTWFuYWdlbWVudC5SZXNvdXJjZVByb3ZpZGVycy5Bc3NldEJ1bmRsZVJlcXVlc3RPcHRpb25z6gEAAHsAIgBtAF8ASABhAHMAaAAiADoAIgAxAGMAYwBhADUAOABmADAAMQBiAGQAZQBkADMANgAwAGEAZgBmADkANwA1AGYAMgBjADAAZABjADQANQAzADAAIgAsACIAbQBfAEMAcgBjACIAOgAyADQAOAA1ADAANQA2ADgANQA5ACwAIgBtAF8AVABpAG0AZQBvAHUAdAAiADoAMAAsACIAbQBfAEMAaAB1AG4AawBlAGQAVAByAGEAbgBzAGYAZQByACIAOgBmAGEAbABzAGUALAAiAG0AXwBSAGUAZABpAHIAZQBjAHQATABpAG0AaQB0ACIAOgAtADEALAAiAG0AXwBSAGUAdAByAHkAQwBvAHUAbgB0ACIAOgAwACwAIgBtAF8AQgB1AG4AZABsAGUATgBhAG0AZQAiADoAIgBlADYAZQAzADYAZAA0ADgAMwA0AGEAMwBkADEAMgBlAGIAMgA1ADEAYQAyADEAMQA5ADcAOABlADUAZQAxADMAIgAsACIAbQBfAEIAdQBuAGQAbABlAFMAaQB6AGUAIgA6ADMAMgAzADQAMAAsACIAbQBfAFUAcwBlAEMAcgBjAEYAbwByAEMAYQBjAGgAZQBkAEIAdQBuAGQAbABlAHMAIgA6AHQAcgB1AGUAfQAHTFVuaXR5LlJlc291cmNlTWFuYWdlciwgVmVyc2lvbj0wLjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPW51bGxKVW5pdHlFbmdpbmUuUmVzb3VyY2VNYW5hZ2VtZW50LlJlc291cmNlUHJvdmlkZXJzLkFzc2V0QnVuZGxlUmVxdWVzdE9wdGlvbnPuAQAAewAiAG0AXwBIAGEAcwBoACIAOgAiAGIAYQBlAGYAOABjADUAOABmADYANAAzAGEAZgBmADcAZgBkADQAOABiAGYAMgBjADMAOQBmADQAOQBhADMAYgAiACwAIgBtAF8AQwByAGMAIgA6ADIAMAA5ADYANAA4ADMAOQAxADUALAAiAG0AXwBUAGkAbQBlAG8AdQB0ACIAOgAwACwAIgBtAF8AQwBoAHUAbgBrAGUAZABUAHIAYQBuAHMAZgBlAHIAIgA6AGYAYQBsAHMAZQAsACIAbQBfAFIAZQBkAGkAcgBlAGMAdABMAGkAbQBpAHQAIgA6AC0AMQAsACIAbQBfAFIAZQB0AHIAeQBDAG8AdQBuAHQAIgA6ADAALAAiAG0AXwBCAHUAbgBkAGwAZQBOAGEAbQBlACIAOgAiAGIAZQAyADkANwAzADAAOABmADIAMgBkADUAZgA3ADAAZQBkADUAMABmAGYAYQA3ADkAZABmADMAMwBjAGYAMQAiACwAIgBtAF8AQgB1AG4AZABsAGUAUwBpAHoAZQAiADoANQAzADYAMwA3ADQAMgAsACIAbQBfAFUAcwBlAEMAcgBjAEYAbwByAEMAYQBjAGgAZQBkAEIAdQBuAGQAbABlAHMAIgA6AHQAcgB1AGUAfQA=\",\"m_resourceTypes\":[{\"m_AssemblyName\":\"UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.TextAsset\"},{\"m_AssemblyName\":\"UnityEngine.AudioModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.Audio.AudioMixer\"},{\"m_AssemblyName\":\"UnityEngine.AudioModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.Audio.AudioMixerGroup\"},{\"m_AssemblyName\":\"Assembly-CSharp-firstpass, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"AF.Core.Utility.Paths\"},{\"m_AssemblyName\":\"UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.Texture2D\"},{\"m_AssemblyName\":\"Unity.TextMeshPro, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"TMPro.TMP_Settings\"},{\"m_AssemblyName\":\"UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.Material\"},{\"m_AssemblyName\":\"Unity.TextMeshPro, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"TMPro.TMP_FontAsset\"},{\"m_AssemblyName\":\"UnityEngine.CoreModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.Shader\"},{\"m_AssemblyName\":\"Unity.TextMeshPro, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"TMPro.TMP_SpriteAsset\"},{\"m_AssemblyName\":\"Unity.TextMeshPro, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"TMPro.TMP_StyleSheet\"},{\"m_AssemblyName\":\"UnityEngine.UIElementsModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.UIElements.StyleSheet\"},{\"m_AssemblyName\":\"UnityEngine.TextRenderingModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.Font\"},{\"m_AssemblyName\":\"Unity.ResourceManager, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.ResourceManagement.ResourceProviders.SceneInstance\"},{\"m_AssemblyName\":\"Unity.ResourceManager, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.ResourceManagement.ResourceProviders.IAssetBundleResource\"},{\"m_AssemblyName\":\"UnityEngine.AudioModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\",\"m_ClassName\":\"UnityEngine.AudioClip\"}],\"m_InternalIdPrefixes\":[]}","link":"/StreamingAssets/aa/catalog.json"},{"title":"","text":"var UnityLoader=UnityLoader||{Compression:{identity:{require:function(){return{}},decompress:function(e){return e}},gzip:{require:function(e){var t={\"inflate.js\":function(e,t,r){\"use strict\";function n(e){if(!(this instanceof n))return new n(e);this.options=s.assign({chunkSize:16384,windowBits:0,to:\"\"},e||{});var t=this.options;t.raw&&t.windowBits>=0&&t.windowBits=0&&t.windowBits15&&t.windowBits0||0===f.avail_out)&&r!==l.Z_STREAM_END);return r===l.Z_STREAM_END&&(n=l.Z_FINISH),n===l.Z_FINISH?(r=a.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l.Z_OK):n!==l.Z_SYNC_FLUSH||(this.onEnd(l.Z_OK),f.avail_out=0,!0)},n.prototype.onData=function(e){this.chunks.push(e)},n.prototype.onEnd=function(e){e===l.Z_OK&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=s.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},r.Inflate=n,r.inflate=o,r.inflateRaw=i,r.ungzip=o},\"utils/common.js\":function(e,t,r){\"use strict\";var n=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Int32Array;r.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if(\"object\"!=typeof r)throw new TypeError(r+\"must be non-object\");for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n])}}return e},r.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var o={arraySet:function(e,t,r,n,o){if(t.subarray&&e.subarray)return void e.set(t.subarray(r,r+n),o);for(var i=0;i>>6&63,t[a++]=128|63&r);return t},r.buf2binstring=function(e){return n(e,e.length)},r.binstring2buf=function(e){for(var t=new o.Buf8(e.length),r=0,n=t.length;r=0&&128===(192&e[r]);)r--;return rt?r:t}},\"zlib/inflate.js\":function(e,t,r){\"use strict\";function n(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)24&255,r.check=v(r.check,Le,4,0)),f=0,h=0,r.mode=F;case F:for(;h>>8&255,r.check=v(r.check,Le,2,0)),f=0,h=0,r.mode=z;case z:if(1024&r.flags){for(;h8&255,r.check=v(r.check,Le,2,0)),f=0,h=0}else r.head&&(r.head.extra=null);r.mode=V;case V:if(1024&r.flags&&(w=r.length,w>d&&(w=d),w&&(r.head&&(Ue=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),y.arraySet(r.head.extra,o,a,w,Ue)),512&r.flags&&(r.check=v(r.check,o,w,a)),d-=w,a+=w,r.length-=w),r.length))break e;r.length=0,r.mode=q;case q:if(2048&r.flags){if(0===d)break e;w=0;do Ue=o[a+w++],r.head&&Ue&&r.length>=2,h-=2;break;case K:for(f>>>=7&h,h-=7&h;h16^65535)){e.msg=\"invalid stored block lengths\",r.mode=fe;break}if(r.length=65535&f,f=0,h=0,r.mode=Q,t===W)break e;case Q:r.mode=_;case _:if(w=r.length){if(w>d&&(w=d),w>l&&(w=l),0===w)break e;y.arraySet(i,o,a,w,s),d-=w,a+=w,l-=w,s+=w,r.length-=w;break}r.mode=j;break;case $:for(;h=5,h-=5,r.ndist=(31&f)+1,f>>>=5,h-=5,r.ncode=(15&f)+4,f>>>=4,h-=4,r.nlen>286||r.ndist>30){e.msg=\"too many length or distance symbols\",r.mode=fe;break}r.have=0,r.mode=ee;case ee:for(;r.have>16&255,ye=65535&Be,!(we>>=2,h-=2}else if(17===ye){for(ke=we+3;h=we,h-=we,Ue=0,w=3+(7&f),f>>>=3,h-=3}else{for(ke=we+7;h=we,h-=we,Ue=0,w=11+(127&f),f>>>=7,h-=7}if(r.have+w>r.nlen+r.ndist){e.msg=\"invalid bit length repeat\",r.mode=fe;break}for(;w--;)r.lens[r.have++]=Ue}}if(r.mode===fe)break;if(0===r.lens[256]){e.msg=\"invalid code -- missing end-of-block\",r.mode=fe;break}if(r.lenbits=9,Ee={bits:r.lenbits},xe=U(E,r.lens,0,r.nlen,r.lencode,0,r.work,Ee),r.lenbits=Ee.bits,xe){e.msg=\"invalid literal/lengths set\",r.mode=fe;break}if(r.distbits=6,r.distcode=r.distdyn,Ee={bits:r.distbits},xe=U(k,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,Ee),r.distbits=Ee.bits,xe){e.msg=\"invalid distances set\",r.mode=fe;break}if(r.mode=re,t===W)break e;case re:r.mode=ne;case ne:if(d>=6&&l>=258){e.next_out=s,e.avail_out=l,e.next_in=a,e.avail_in=d,r.hold=f,r.bits=h,A(e,m),s=e.next_out,i=e.output,l=e.avail_out,a=e.next_in,o=e.input,d=e.avail_in,f=r.hold,h=r.bits,r.mode===j&&(r.back=-1);break}for(r.back=0;Be=r.lencode[f&(1>24,be=Be>>>16&255,ye=65535&Be,!(we24,be=Be>>>16&255,ye=65535&Be,!(ge+we=ge,h-=ge,r.back+=ge}if(f>>>=we,h-=we,r.back+=we,r.length=ye,0===be){r.mode=de;break}if(32&be){r.back=-1,r.mode=j;break}if(64&be){e.msg=\"invalid literal/length code\",r.mode=fe;break}r.extra=15&be,r.mode=oe;case oe:if(r.extra){for(ke=r.extra;h>>16&255,ye=65535&Be,!(we24,be=Be>>>16&255,ye=65535&Be,!(ge+we=ge,h-=ge,r.back+=ge}if(f>>>=we,h-=we,r.back+=we,64&be){e.msg=\"invalid distance code\",r.mode=fe;break}r.offset=ye,r.extra=15&be,r.mode=ae;case ae:if(r.extra){for(ke=r.extra;hw){if(w=r.offset-w,w>r.whave&&r.sane){e.msg=\"invalid distance too far back\",r.mode=fe;break}w>r.wnext?(w-=r.wnext,b=r.wsize-w):b=r.wnext-w,w>r.length&&(w=r.length),me=r.window}else me=i,b=s-r.offset,w=r.length;w>l&&(w=l),l-=w,r.length-=w;do i[s++]=me[b++];while(--w);0===r.length&&(r.mode=ne);break;case de:if(0===l)break e;i[s++]=r.length,l--,r.mode=ne;break;case le:if(r.wrap){for(;h8^o[255&(e^t[s])];return e^-1}var i=n();t.exports=o},\"zlib/inffast.js\":function(e,t,r){\"use strict\";var n=30,o=12;t.exports=function(e,t){var r,i,a,s,d,l,u,c,f,h,p,m,w,b,y,g,v,A,U,x,E,k,B,L,W;r=e.state,i=e.next_in,L=e.input,a=i+(e.avail_in-5),s=e.next_out,W=e.output,d=s-(t-e.avail_out),l=s+(e.avail_out-257),u=r.dmax,c=r.wsize,f=r.whave,h=r.wnext,p=r.window,m=r.hold,w=r.bits,b=r.lencode,y=r.distcode,g=(116&255,0===U)W[s++]=65535&A;else{if(!(16&U)){if(0===(64&U)){A=b[(65535&A)+(m&(116&255,!(16&U)){if(0===(64&U)){A=y[(65535&A)+(m&(1","link":"/Build/UnityLoader.js"},{"title":"","text":"!function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(\"Phaser\",[],e):\"object\"==typeof exports?exports.Phaser=e():t.Phaser=e()}(window,function(){return function(t){var e={};function i(n){if(e[n])return e[n].exports;var s=e[n]={i:n,l:!1,exports:{}};return t[n].call(s.exports,s,s.exports,i),s.l=!0,s.exports}return i.m=t,i.c=e,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:n})},i.r=function(t){Object.defineProperty(t,\"__esModule\",{value:!0})},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p=\"\",i(i.s=1360)}([function(t,e){function i(t,e,i){var n=i?t[e]:Object.getOwnPropertyDescriptor(t,e);return!i&&n.value&&\"object\"==typeof n.value&&(n=n.value),!(!n||!function(t){return!!t.get&&\"function\"==typeof t.get||!!t.set&&\"function\"==typeof t.set}(n))&&(void 0===n.enumerable&&(n.enumerable=!0),void 0===n.configurable&&(n.configurable=!0),n)}function n(t,e){var i=Object.getOwnPropertyDescriptor(t,e);return!!i&&(i.value&&\"object\"==typeof i.value&&(i=i.value),!1===i.configurable)}function s(t,e,s,r){for(var a in e)if(e.hasOwnProperty(a)){var h=i(e,a,s);if(!1!==h){if(n((r||t).prototype,a)){if(o.ignoreFinals)continue;throw new Error(\"cannot override final property '\"+a+\"', set Class.ignoreFinals = true to skip\")}Object.defineProperty(t.prototype,a,h)}else t.prototype[a]=e[a]}}function r(t,e){if(e){Array.isArray(e)||(e=[e]);for(var i=0;i>8|0))/255,(255&(0|t))/255]},getComponentCount:function(t,e){for(var i=0,n=0;n","link":"/phaser.min.js"}]}