{"posts":[{"title":"2022&#x2F;7&#x2F;15模拟赛记","text":"ych 出的模拟赛。 /bx /bx /bx 原题场 /fn /fn /fn 赛时T1 string 发现是 NOIP 原题，然而忘记自己做过了。 想了一会发现自己做过，但是 ych 这个【】居然卡常，1e6-&gt;3e6 /oh 然而自己之前写的是 BIT，吸氧后 900+ms，感觉有点危险，写了个 $O(n\\ln n+n\\cdot 26)$ 的，感觉也许能过。 ych 啊 ych，既然已经加强数据范围了就不要出毒瘤数据了吧。 预估 100pts T2 work上午刚做过 P4158 粉刷匠，就只想着背包了。 然后就写了个背包，复杂度 $O(na^2nb^2n)$，感觉很危险，有可能能过。 预估 80pts T3 sort一开始瞎推推出来个 _逆序对数+递归层数_，然而这玩意居然是能过样例的。 写了个暴力对拍下，发现错了，然后白兰去看 T4 了。 最后 30min 随便想了一个结论：每个点到最后面的比它小的点的距离之和，发现能过样例，和暴力拍拍也对的 /xia 最后造了个 2000 个 1e9 的数据，发现输出 0，于是写了个特判原数组已经有序就输出 $n$。 用 BIT 实现的，复杂度 $O(n \\log n)$，1e5 的数据应该轻松。 预估 100pts T4 magic想到 mod 不能约分，直接放弃。 预估 0pts 总分预估 100+80+100+0=280pts 赛后T1 被卡 T 成 80pts，T2,3,4 发挥稳定 总分 80+80+100+0=260pts 发现 T2 正解实际上要二分，有单谷性质 /px 蓝 /bx T3 居然结论猜对了 T4 矩阵乘法，维护前缀后缀积，然而 ych 卡带 log 的线段树做法 /baojin ych 没开 O2，重测 /fn /fn /fn 吸氧后 T1 过了。 O2 /qiang 总分 100+80+100+0=280pts 以下为第二天 gzy T3 被卡后发现我的也挂了 successful hack! gzy /bx 总分 100+80+90+0=270pts T1 被 sanwei 卡成 96 分。 反正本来也过不了的。 总分 96+80+90+0=266pts sanwei /bx Links贴下原题链接吧 T1 string NOIP2020 字符串匹配 T2 work WC2001 高性能计算机 T3 sort USACO18OPEN Out of Sorts P T4 magic 「LibreOJ NOI Round #2」单枪匹马 打的太差就不贴代码了 另附 ych 写的题解，如果像我一样觉得出题人很可爱的可以不看 题解 A.string题意给定字符串 $S$，求把 $S$ 拆分为 $ABAB…ABC$ 这样的形式的方案数。 做法考虑枚举 $AB$ 的长度，用 $Z$ 函数求出最多连续 $AB$ 作为前缀的数量。 考虑 $C$ 中出现奇数次的字母的个数，发现对于 $AB$ 长度固定时只有两种取值，和选的 $AB$ 个数有关。 其中一种取值是固定的，另一种在枚举长度时可以递推求得。 然后在 $AB$ 中选择一个 $A$ 就是选择一个前缀，这个前缀出现奇数次字母的个数比 $C$ 出现奇数次字母的个数少。 这个用 bit 维护就可以了，这样是 nlog26。 进一步分析发现，$C$ 另一种取值每次变化量最多为 1，因此就不需要bit，只需要根据他这一次的变化计算贡献。把前面的结果加以利用。 B.work每个人有四个参数，求解决na个A和nb个B的最小时间。 做法对第 $i$ 个人，考虑预处理 $cost(x,y)$ 表示解决 $x$ 个 $A$ 和 $y$ 个 $B$ 的最小代价。 这一部分是 $O(nm^3)$ 的。 然后如果是 $dp(i,x,y)$ 表示前 $i$ 个人解决 $x$ 个 $A$ 和 $y$ 个 $B$，转移枚举 $i$ 选几个 $A$ 几个 $B$，是 $O(nm^4)$。可以获得80分。 考虑优化。 由于答案是所有人的 max，可以考虑二分。 $dp(i,j)$ 表示 $i$ 个人在限制内解决 $j$ 个 $A$ 最多选的 $B$ 的个数。 然后这样发现是不对的。 因为 $cost(x,y)$ 并不是单调的。但是单谷的。 考虑证明。在 $x$ 固定的时候 $y$ 增加使得答案更小，说明把 $B$ 插入 $A$，且为独立的一段。 然后 $B$ 能有效插入的次数显然是有限的。不能插了以后都不能插。 所以 $dp(i,j)$ 应该存一个区间。 判 $nb$ 是否在区间内。 C.sort题意自己看吧。 做法观察到这个 $cnt$ 每次增加的时候会增加一个 $length(A)$。 数形结合，对长度为length(A)的序列 bubble_sort，统计答案，实际上相当于把这个贡献均摊到每个点上。 于是考虑对每个点分别计算贡献。 这个点会连续被排序直到前后两个位置都成为分界线。 于是计算每个位置成为分界线的时间。 冒泡排序是稳定排序，所以Ai相不相同并不重要，可以全部当成不同的做，用双关键字。 然后要把所有&lt;x的放到前面去。 考虑冒泡排序的本质，就是分为若干段，每一段进行一个循环左移。 这个线一定会被包含在某一段中，然后一段结束的位置由于已经是分界线，不存在应该往前的，所以发现所有应该往前放的都会往前一位。而且这一段的开头一定不会是应该放在前面的。若是应该放在前面的，则一整段都是，又根据分界线，前面也都是，个数就不对了。 每个点最开始一定会被排一下，所以要和1取个max。 D.magic题意自己看。 做法先考虑暴力，$a+\\frac x y=\\frac {ay+x} {y}$，然后结合的时候可能还要倒过来。 $x$ 和 $y$ 互质，所以那个 $ay+x$ 和 $y$ 也互质。 所以就不用考虑约分，直接模意义下也可以做。 然后你发现把分子分母上矩阵，就可以做了。 我把线段树维护卡了，直接前缀和，处理矩阵的逆元。 THE END","link":"/2023/01/06/2022-7-15%E6%A8%A1%E6%8B%9F%E8%B5%9B%E8%AE%B0/"},{"title":"ABC255比赛笔记","text":"比赛传送门 前言做出来 7 题，第一次做出 Ex，感觉还不错。 上一次做出 7 题还是在很久以前呢 /wx 为啥 ABC 前几题越来越难了啊，感觉 C 都有 D 的水平了。 交错程序一发，可真有我的。 题解A - You should output ARC, though this is ABC.题目名字好废话，看个乐子就好。 B - Light It Up题意给定若干个点，其中一些点上有灯，灯能照到半径为 $R$ 的圆内的地方。求要找到所有点，$R$ 的最小值，$N\\le 1000$。 做法对于每个点找离它最近的灯，把所有距离取 $\\max$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 0x3f3f3f3f#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); }void err(istream_iterator&lt;string&gt; it) {}template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) { cerr &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; '=' &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl; err(++it, args...);}int T_, case_;int n, k, a;bool f[1010];double x[1010], y[1010], mn, ans = 0;void solve() { cin &gt;&gt; n &gt;&gt; k; rep(i, k)cin &gt;&gt; a, f[a - 1] = 1; rep(i, n)cin &gt;&gt; x[i] &gt;&gt; y[i]; rep(i, n) { mn = MAXN; rep(j, n) { if (!f[j])continue; mn = min(mn, sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]))); } ans = max(ans, mn); } cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; ans;}int main() { T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} C - ±1 Operation 1题意给定一个等差数列的首项 $A$，公差 $D$ 和项数 $N$，每次操作可以将 $X+1$ 或 $-1$。求最少要多少次操作才能使 $X$ 和等差数列中某个数相等。 $N\\le 10^{12},-10 ^6 \\le D \\le 10^6, -10^{18} \\le X,A\\le 10^{18}$ 做法首先，如果 $D=0$，那么 $X$ 只能变成 $A$，输出 $\\left| X-A\\right|$ 即可。 如果 $D&lt;0$，则把 $A$ 变成 $A+D\\cdot (N-1)$，把 $D$ 变成 $-D$，这样就转化成 $D&gt;0$ 的情况了。 现在已经保证了 $D&gt;0$，所以就找出离 $X$ 最近的在等差数列中的值 $Y$，用 $\\left| X-Y\\right|$ 更新答案，FG 因为不会考虑边界就直接左右多偏移几个，注意判断超出等差数列的情况。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 0x3f3f3f3f#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); }void err(istream_iterator&lt;string&gt; it) {}template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) { cerr &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; '=' &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl; err(++it, args...);}int T_, case_;ll x, a, d, n, y, ans = -1;void solve() { cin &gt;&gt; x &gt;&gt; a &gt;&gt; d &gt;&gt; n; if (!d) { cout &lt;&lt; abs(x - a); return; } if (d &lt; 0) { a += d * (n - 1); d *= -1; } if (x &gt;= a) { y = a + (x - a) / d * d; for (ll z = y - d * 3;z &lt;= y + d * 3;z += d) { if (z&lt;a || z&gt;a + d * (n - 1))continue; if (ans == -1 || ans &gt; abs(x - z))ans = abs(x - z); } } ll z; z = a; if (ans == -1 || ans &gt; abs(x - z))ans = abs(x - z); z = a + d * (n - 1); if (ans == -1 || ans &gt; abs(x - z))ans = abs(x - z); cout &lt;&lt; ans;}int main() { T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} D - ±1 Operation 2题意给定一个长度为 $N$ 的数组 $A$，每次操作可以把其中一个数 $+1$ 或 $-1$，有 $Q$ 次查询，第 $i$ 次询问最少多少次可以全部变成 $X_i$。 $N,Q \\le 2\\times 10^5,A_i,X_i \\le 10^9$ 做法先排序，处理出前缀和。 查询时先 lower_bound 出有 $P$ 个数 $&lt; X_i$，用前缀和处理，这部分答案就是 $P\\cdot X_i-sum_p$，其余的 $\\ge X_i$ 的部分同理。 Code123456789101112131415161718192021222324252627282930313233343536373839404142/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 0x3f3f3f3f#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); }void err(istream_iterator&lt;string&gt; it) {}template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) { cerr &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; '=' &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl; err(++it, args...);}int T_, case_;int n, q;ll a[200005], x, sum[200005];void solve() { cin &gt;&gt; n &gt;&gt; q; repp(i, n)cin &gt;&gt; a[i]; sort(a + 1, a + 1 + n); repp(i, n)sum[i] = sum[i - 1] + a[i]; while (q--) { cin &gt;&gt; x; ll p = upper_bound(a + 1, a + 1 + n, x) - a; cout &lt;&lt; (p - 1) * x - sum[p - 1] + (sum[n] - sum[p - 1]) - (n - p + 1) * x &lt;&lt; endl; }}int main() { T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} E - Lucky Numbers题意有一个未知的长度为 $N$ 的数列 $A$ 满足 $A_i+A_{i+1}=S_i$，给定 $S$ 和一个大小为 $M$ 的集合 $X$，求最多有多少个 $i$ 满足 $A_i \\in X$。 $N \\le 10^6,M \\le 10,-10^9 \\le S_i,X_i \\le 10^9$ 做法先钦定 $A_1=0$，推出整个 $A$。 容易得到，如果 $A_1+1$，那么必定会有 $A_2-1,A_3+1,A_4-1,A_5+1\\dots$，即奇数下标的 $+1$，偶数下标的 $-1$。 对于每个奇数的 $i$ 处理出所有 $X_j-A_i$，对于每个偶数的 $i$ 处理出所有 $A_i-X_j$，这样就可以统计出 $A_1+W$ 后的答案，即为 $W$ 在统计中出现的次数。在左右出现次数中取最大值即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (ll i = a; i &lt;= b; i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 0x3f3f3f3f#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); }void err(istream_iterator&lt;string&gt; it) {}template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) { cerr &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; '=' &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl; err(++it, args...);}ll T_, case_;ll n, m, s[100005], x[20], a[100005], ans = 0;vector&lt;ll&gt;v;void solve() { cin &gt;&gt; n &gt;&gt; m; rep(i, n - 1)cin &gt;&gt; s[i]; rep(i, m)cin &gt;&gt; x[i]; forr(i, 1, n - 1)a[i] = s[i - 1] - a[i - 1]; rep(i, n) { rep(j, m) { ll tmp; if (i % 2 == 0)tmp = a[i] - x[j]; else tmp = x[j] - a[i]; v.pb(tmp); } } sort(v.begin(), v.end()); ll l, r = 0; while (r &lt; (ll)v.size()) { l = r; while (r + 1 &lt; (ll)v.size() &amp;&amp; v[r + 1] == v[l])r++; ans = max(ans, r - l + 1); r++; } cout &lt;&lt; ans;}int main() { T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} F - Pre-order and In-order题意给出一棵树的前序遍历 $P$ 和中序遍历 $I$，求这棵树的形态，或判断无解。 $N \\le 2\\times 10^5$ 做法CSP 初赛经典题了属于是。 考虑 $P_{l\\dots r}$ 匹配 $I_{L\\dots R}$。 显然 $P_l$ 为根，所以就可将 $I$ 划分成两段，即 $P_l$ 的左边和右边。知道左右子树大小后，就可以将 $P_{L+1\\dots R}$ 划分成两段，递归即可。 如果 $P_l$ 在 $I_{L\\dots R}$ 中没有出现则判断无解。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 0x3f3f3f3f#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); }void err(istream_iterator&lt;string&gt; it) {}template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) { cerr &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; '=' &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl; err(++it, args...);}int T_, case_;int n, a[200005], b[200005], p[200005];int son[200005][2];bool ans = 1;void dfs(int l, int r, int L, int R) { if (l &gt; r || L &gt; R || !ans)return; int x = a[l], y = p[a[l]], lenl = y - L, lenr = R - y; if (y&lt;L || y&gt;R)ans = 0; if (lenl &gt; 0)son[x][0] = a[l + 1] + 1, dfs(l + 1, l + lenl, L, y - 1); if (lenr &gt; 0)son[x][1] = a[l + lenl + 1] + 1, dfs(l + lenl + 1, r, y + 1, R);}void solve() { cin &gt;&gt; n; rep(i, n)cin &gt;&gt; a[i], a[i]--; rep(i, n)cin &gt;&gt; b[i], b[i]--, p[b[i]] = i; if (a[0]) { cout &lt;&lt; -1; return; } dfs(0, n - 1, 0, n - 1); if (!ans)cout &lt;&lt; -1; else rep(i, n)cout &lt;&lt; son[i][0] &lt;&lt; ' ' &lt;&lt; son[i][1] &lt;&lt; endl;}int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} G - Constrained Nim没看。 Ex - Range Harvest Query题意有 $N$ 棵树，第 $0$ 天它们都没有果子，每天晚上，第 $i$ 棵树会结出 $i$ 个果子。 共有 $Q$ 次采摘，第 $i$ 次在第 $D_i$ 天晚上，采走第 $L_i$ 到 $R_i$ 棵树上所有的果子。 对于每次采摘，输出采到了多少果子，对 $998244353$ 取模。 $N,D_i \\le 10^{18},Q \\le 2 \\times 10^5,D_i&lt;D_{i+1}$ 做法珂朵莉树模板题。 感谢 lxl！ 维护每棵树最后被采摘的区间，每次用等差数列求和处理区间贡献，再区间赋值即可。 由于每次操作只会 split 出 至多 $2$ 个区间，所以区间总数是 $O(Q)$ 的，并且查询复杂度和包含的区间个数有关，查询后会将这些区间全部合并到一起，所以最多只会查询 $O(Q)$ 个区间，算上 set 复杂度，总时间复杂度为 $O(Q \\log Q)$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 0x3f3f3f3f#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); }void err(istream_iterator&lt;string&gt; it) {}template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) { cerr &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; '=' &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl; err(++it, args...);}int T_, case_;struct Node { ll l, r; mutable ll val; Node(ll a = -1, ll b = -1, ll c = 0) { l = a, r = b, val = c; } bool operator &lt; (const Node&amp; a) const { return l &lt; a.l; }};set&lt;Node&gt;s;bool cmp(pair&lt;ll, ll&gt;x, pair&lt;ll, ll&gt;y) { return x.first &lt; y.first;}set&lt;Node&gt;::iterator split(ll pos) { set&lt;Node&gt;::iterator it = s.lower_bound(Node(pos)); if (it != s.end() &amp;&amp; it-&gt;l == pos)return it; --it; Node tmp = *it; s.erase(it); s.insert(Node(tmp.l, pos - 1, tmp.val)); return s.insert(Node(pos, tmp.r, tmp.val)).first;}void assign(ll l, ll r, ll val) { set&lt;Node&gt;::iterator itr = split(r + 1), itl = split(l); s.erase(itl, itr); s.insert(Node(l, r, val));}ll qpow(ll a, ll x, ll y) { ll ans = 1; a %= y; while (x) { if (x &amp; 1)ans = (ans * a) % y; a = (a * a) % y; x &gt;&gt;= 1; } return ans;}ll e_2;ll query(ll l, ll r, ll d) { set&lt;Node&gt;::iterator itr = split(r + 1), itl = split(l); ll ans = 0; for (set&lt;Node&gt;::iterator it = itl; it != itr; it++) { ll L = it-&gt;l, R = it-&gt;r, lst = it-&gt;val; ll sum = (L % MOD + R % MOD) % MOD * ((R - L + 1) % MOD) % MOD * e_2 % MOD; ans = (ans + (d % MOD - lst) % MOD * sum % MOD) % MOD; } return (ans + MOD) % MOD;}ll n, q, d, l, r;void solve() { e_2 = qpow(2, MOD - 2, MOD); cin &gt;&gt; n &gt;&gt; q; s.insert(Node(1, n, 0)); while (q--) { cin &gt;&gt; d &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(l, r, d) &lt;&lt; endl; assign(l, r, d); }}int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} 后记赛后难度出来了，果然 G&gt;Ex 呢 /hx","link":"/2023/01/06/ABC255%E6%AF%94%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"title":"CF1680F Lenient Vertex Cover","text":"题目传送门 DFS 树的性质。 首先注意到题面中的这一句话： 最多只能有一条边，满足两个顶点都在这个点集中。 显然，“最多只能有一条边”意思就是有 $0$ 条或 $1$ 条。 0 条所以每条边都恰好只有一个顶点在点集中。 很自然想到二分图染色，每条边两个顶点颜色不同。 所以只要这个图是二分图，就一定有解。 1 条有一条边的两个点同色，那么去掉这个边后，剩下的图一定就是一个二分图，就转化成了上一个情况。 先 DFS 一遍。一个显然的重要的性质是：对于原图中的每条边，要么是 DFS 树中的一条边，要么是一条返祖边（即一个点连向它祖先的边）。 因为二分图中没有奇环，所以这条去掉的边一定在所有奇环上，而不能在任何一个偶环上（这样去掉之后就全是偶环了）。 考虑去掉什么边。 返祖边因为一个环在 DFS 树中一定是一条链加上一条返祖边，所以在 DFS 遇到返祖边时判断这个环是奇环还是偶环，就能统计出奇环数量了。如果奇环数量为 $1$，那么直接去掉那条返祖边即可。 树边在统计环时把环上的所有树边都标记 $+1$，最后看是否有一个树边满足： 所在的奇环数 $=$ 奇环总数 所在的偶环数 $=0$ 即可。 标记时用树上差分即可，不会的同学可以左转 OI Wiki。 最后判断答案时只需要再 DFS 一遍，按照深度奇偶性染色即可。 注意：有可能结果是：一条边满足两个顶点都不在点集中，其他每条边都有一个顶点在点集中。这时候只需要把所有颜色反转即可。 Code","link":"/2023/01/06/CF1680F-Lenient-Vertex-Cover/"},{"title":"POJ1874 Trade on Verweggistan","text":"题目传送门 本题最大难点：读题。 首先说一下题意： 有 $w$ 堆货物，第 $i$ 堆有 $b_i$ 个，从上往下给定每个货物的进价。所有货物的售价都是 $10$，但是如果想买一件货物，必须要先买在它上面的所有货物。求出最大利润，以及要达成这个利润，需要买多少个货物，可能有多种方案，从小到大输出。如果超过 $10$ 个只需要输出最小的 $10$ 个。 显然先把每堆的前缀和从大到小排序，最大利润就是每堆 rk1 的前缀和加起来。 比较烦的是有的堆前缀和可能 $\\le 0$。 这里有个小 trick：每堆在排序时加一个元素 $(0,0)$，表示前 $0$ 个的利润和是 $0$。这样就可以挤掉 $\\le 0$ 的情况。 接下来处理货物数。 最小就是每堆 rk1 的长度的和，贪心计算出接下来最小的方案是什么：遍历一遍现有的所有方案，算出所有拓展的方式取 min，然后把这种方案加到答案队伍里。要去重。已经有 $10$ 个不重复的就 break。 注意： $b$ 有可能是 $0$ 输出格式，每组数据之间要空一行 实在不行去 udebug 上找组数据测测 我承认我加了 IO 优化才过。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt;v;int rk[20000][55];void solve() { v.resize(n); cnt = 0; rep(i, n) { cin &gt;&gt; m; sum = 0; v[i].clear(); v[i].pb(mp(0, 0)); rep(j, m) { cin &gt;&gt; a; sum += 10 - a; v[i].pb(mp(-sum, j + 1)); } sort(v[i].begin(), v[i].end()); } sum = 0; rep(i, n)sum -= v[i][0].fi; ans = 1; cnt = 1; init(rk[0], 0); rep(i, n) rk[0][n] += v[i][0].se; rep(I, 10000) { int mn = MAXN, id1, id2; rep(i, ans) { rep(j, n) { if (rk[i][j] &lt; 0 || rk[i][j] &gt;= (int)v[j].size() - 1 || v[j][rk[i][j] + 1].fi != v[j][rk[i][j]].fi)continue; if (rk[i][n] + v[j][rk[i][j] + 1].se - v[j][rk[i][j]].se &lt; mn) { mn = rk[i][n] + v[j][rk[i][j] + 1].se - v[j][rk[i][j]].se; id1 = i; id2 = j; } } } if (mn == MAXN)break; rep(i, n)rk[ans][i] = rk[id1][i]; rk[ans][id2]++; rk[id1][id2] = -1; rk[ans][n] = mn; if (rk[ans][n] != rk[ans - 1][n])cnt++; ans++; if (cnt == 10)break; } cout &lt;&lt; &quot;Workyards &quot; &lt;&lt; T_ &lt;&lt; endl; cout &lt;&lt; &quot;Maximum profit is &quot; &lt;&lt; sum &lt;&lt; &quot;.\\n&quot;; cout &lt;&lt; &quot;Number of pruls to buy:&quot;; rep(i, ans)if (!i || rk[i][n] != rk[i - 1][n])cout &lt;&lt; ' ' &lt;&lt; rk[i][n]; cout &lt;&lt; endl;}int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); T_ = 1; while (cin &gt;&gt; n) { if (!n)break; if (T_ &gt; 1)cout &lt;&lt; endl; solve(); T_++; } return 0;} 另一种也许可行的办法 爆搜出所有方案，放到 set 里去找到前十。上次 CSP-J 被 set 坑到 TLE ，就没敢用。","link":"/2023/01/06/POJ1874-Trade-on-Verweggistan/"},{"title":"FFT字符串匹配","text":"前言字符串匹配，一个广泛而深刻的话题。 现有的字符串匹配算法有很多，例如 KMP，AC 自动机等等。但是，它们都是一位一位的处理，也就是说，基础操作是单个字符比较（哈希除外）。如果把整个字符串比较，效率是极其低下的。但将字符串转化为多项式后，多项式的运算无疑为整个字符串比较提供了绝佳的方法。 最知名但也最臭名昭著的多项式算法莫过于 FFT（快速傅里叶变换）了。实际上，它在字符串匹配方面也有很大的作用。 前置芝士 多项式基础 卷积 FFT 不会的左转 OI Wiki。 一些基础的数学常识 完全平方公式 不会的去翻数学书。 正题普通字符串匹配设 $S$ 为模式串，$T$ 为文本串，$n=\\lvert S \\rvert,m=\\lvert T \\rvert$（字符串下标从 $0$ 开始）。 显然，两个字符串相同，当且仅当它们每一位都相同，这是一句废话。 我们联想到初中一年级的一句重要的话：**如果若干个非负数的和为 $0$，那么它们都为 $0$**。 和为 $0$ 正好对应了 每一位都相同，所以很容易得出这个 完全匹配函数（很重要！之后要考） $$f(x)=\\sum\\limits_{i=0}^{n-1} (S_i-T_{x-n+i+1})^2$$ $f(x)$ 表示 $S$ 与 $T_{(x-n+1)\\dots x}$ 的 匹配值 。 其中平方是为了保证每一项都是非负数。这样，只有每一项都为 $0$（即 $S_i=T_{x+i-1}$），$f(x)$ 才会为 $0$。 显然这个柿子不是很好化简，所以我们要对它进行一点点的变形。 什么柿子容易计算呢？当然是卷积，即： $$f(x)=\\sum\\limits_{i+j=x} A_iB_j$$ 然而之前那个柿子中，$i$ 和 $x-n+i+1$ 加起来显然不是一个定值。如何把这个 $i$ 消掉呢？ 我们考虑把 $S$ 整个串反转，这样原来的 $i$ 就变成了 $n-i-1$。 于是变成： $$f(x)=\\sum\\limits_{i=0}^{n-1} (S_{n-i+1}-T_{x-n+i+1})^2$$ 两个下标相加： $$(n-i+1)+(x-n+i+1)=x$$ 好耶！消掉了！ 于是那个柿子就可以写成： $$f(x)=\\sum\\limits_{i+j=x}(S_i-T_j)^2$$ 用完全平方公式拆开： $$f(x)=\\sum\\limits_{i+j=x}S_i^2-2S_iT_j+T_j^2$$ 显然第一项和第三项可以预处理得到，第二项就是 $S\\cdot T$ 中 $x$ 次项的系数乘上 $-2$，只需要把 $S$ 和 $T$ 看成多项式，FFT 相乘即可。 复杂度 $O(n \\log n)$。 还没有 KMP 快？别急，看接下来的。 带通配符的字符串匹配通配符，即可以匹配任意字符的字符（当然也可以匹配通配符）。 显然这种问题 KMP 就无能为力了。然而，对于 FFT 做法，我们仍然可以用相似的思路解决。 我们发现，原来 完全匹配函数 为 $0$，当且仅当对应的两个字符相同。但是，现在有了通配符，条件应该改为满足以下两个中任意一个： 对应两个字符相同 对应两个字符中有任意一个是通配符 很容易想到设通配符为 $0$（当然其它任何字符都不能为 $0$）。完全匹配函数 就变成了： $$f(x)=\\sum\\limits_{i=0}^{n-1} (S_i-T_{x-n+i+1})^2 \\cdot S_iT_j$$ 如果 $S_i=0$ 或 $T_i=0$，那么 $f(x)$ 仍然为 $0$。 老规矩，反转 $S$： $$f(x)=\\sum\\limits_{i=0}^{n-1} (S_{n-i+1}-T_{x-n+i+1})^2 \\cdot S_iT_j$$ 化成卷积形式： $$f(x)=\\sum\\limits_{i+j=x}(S_i-T_j)^2 \\cdot S_iT_j$$ 完全平方公式： $$f(x)=\\sum\\limits_{i+j=x}S_i^3T_j-2S_i^2T_j^2+S_iT_j^3$$ 看起来很复杂？但每一项还是卷积的形式，于是就用很多次 FFT 解决了。 复杂度 $O(n \\log n)$。 例题模板题残缺的字符串 Luogu 传送门 黑暗爆炸OJ 传送门 做法就是模板题，按上面方法做就完了。 注意数组大小好好算，$eps$ 我取的 $1$ 过了。 常数有点大，吸氧能过。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* Code by FGgirl *//* ♥ Fantasyn &amp; Dormiveglia ♥ */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i,a,n) for(int i=a;i&lt;=n;i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 1100006const double pi = acos(-1);int T_, case_;int n1, n2, n = 1, len = 0;string s, t;int S[MAXN], T[MAXN];struct Complex { double r, i; Complex() { r = i = 0; } Complex(double r_, double i_) :r(r_), i(i_) {}; Complex operator+(const Complex&amp; x)const { return Complex(r + x.r, i + x.i); }; Complex operator-(const Complex&amp; x)const { return Complex(r - x.r, i - x.i); }; Complex operator*(const Complex&amp; x)const { return Complex(r * x.r - i * x.i, i * x.r + r * x.i); };};int rev[MAXN];void FFT(Complex* a, int f) { rep(i, n)if (i &lt; rev[i])swap(a[i], a[rev[i]]); repp(d, log2(n)) { int l = 1 &lt;&lt; d; Complex wn = Complex(cos(2.0 * pi / l), f * sin(2.0 * pi / l)); for (int i = 0;i &lt; n;i += l) { Complex w = Complex(1, 0); rep(j, l / 2) { Complex t = w * a[i + j + l / 2], u = a[i + j]; a[i + j] = u + t; a[i + j + l / 2] = u - t; w = w * wn; } } } if (f == -1)rep(i, n)a[i].r /= n;}Complex a[MAXN], b[MAXN], ans[MAXN];vector&lt;int&gt;v;void solve() { cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; s &gt;&gt; t; reverse(s.begin(), s.end()); while (n &lt; n1 + n2)n *= 2, len++; rep(i, n)rev[i] = (rev[i / 2] / 2 | ((i &amp; 1) &lt;&lt; (len - 1))); rep(i, n1)S[i] = (isalpha(s[i]) ? s[i] - 'a' + 1 : 0); rep(i, n2)T[i] = (isalpha(t[i]) ? t[i] - 'a' + 1 : 0); rep(i, n)a[i] = Complex(S[i] * S[i] * S[i], 0), b[i] = Complex(T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = a[i] * b[i]; rep(i, n)a[i] = Complex(S[i] * S[i], 0), b[i] = Complex(T[i] * T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = ans[i] - Complex(2, 0) * a[i] * b[i]; rep(i, n)a[i] = Complex(S[i], 0), b[i] = Complex(T[i] * T[i] * T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = ans[i] + a[i] * b[i]; FFT(ans, -1); forr(i, n1 - 1, n2 - 1)if (fabs(ans[i].r) &lt;= 1)v.pb(i - n1 + 2); if (v.empty()) { cout &lt;&lt; 0; return; } cout &lt;&lt; v.size() &lt;&lt; endl; rep(i, v.size())cout &lt;&lt; v[i] &lt;&lt; ' ';}int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;} 练习题CF528D Fuzzy Search Luogu 传送门 Codeforces 传送门 题目大意有两个字符串 $S,T$，长度分别为 $n,m$，字符集为 ${A,C,G,T}$，和一个整数 $k$。 我们称 $S$ 在 $T$ 的第 $i$ 位出现了，当且仅当把 $S$ 的首字符和 $T$ 的第 $i$ 个字符对齐后，$S$ 中的每一个字符能够在 $T$ 中找到一个位置偏差不超过 $k$ 的相同字符。 即对于所有的 $j \\in[1,n]$，都存在一个 $p \\in [1,m]$ 使得 $|(i+j-1)-p| \\leq k$ 且 $S_p=T_j$ 。 请求出 $S$ 在 $T$ 中出现的次数。 做法首先把四种字母分开来考虑，最后取四个集合的交即可。 接下来假设只考虑字母 A，其余三个同理。 先把 $S$ 和 $T$ 除了 A 的部分都去掉（即空白），其余位置涂色。 接下来对 $T$ 处理：由于 $T$ 中的一个 A（假设在第 $i$ 位）可以影响到 $[i-k,i+k]$ 这些位置，所以把这些位置全都涂色。 接下来直接匹配即可。对于 $S$ 上有颜色的位置，$T$ 对应位置一定要有颜色；而对于 $S$ 上空白的位置，$T$ 对应位置可以有颜色，也可以是空白。 于是把 $T$ 的涂色部分看成 $1$，空白部分看成 $2$，$S$ 的涂色部分看成 $1$，空白部分看成 $0$（即通配符）。 复杂度 $O(n \\log n)$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* Code by FGgirl *//* ♥ Fantasyn &amp; Dormiveglia ♥ */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i,a,n) for(int i=a;i&lt;=n;i++)#define rep(i,n) forr(i,0,n-1)#define repp(i,n) forr(i,1,n)#define pb push_back#define mp make_pair#define init(a,i) memset(a,i,sizeof(a))#define fi first#define se second#define mod 1000000007#define MOD 998244353#define MAXN 1100006const double pi = acos(-1);int T_, case_;int n1, n2, n = 1, len = 0, k;string s, t;int S[MAXN], T[MAXN];struct Complex { double r, i; Complex() { r = i = 0; } Complex(double r_, double i_) :r(r_), i(i_) {}; Complex operator+(const Complex&amp; x)const { return Complex(r + x.r, i + x.i); }; Complex operator-(const Complex&amp; x)const { return Complex(r - x.r, i - x.i); }; Complex operator*(const Complex&amp; x)const { return Complex(r * x.r - i * x.i, i * x.r + r * x.i); };};int rev[MAXN];void FFT(Complex* a, int f) { rep(i, n)if (i &lt; rev[i])swap(a[i], a[rev[i]]); repp(d, log2(n)) { int l = 1 &lt;&lt; d; Complex wn = Complex(cos(2.0 * pi / l), f * sin(2.0 * pi / l)); for (int i = 0;i &lt; n;i += l) { Complex w = Complex(1, 0); rep(j, l / 2) { Complex t = w * a[i + j + l / 2], u = a[i + j]; a[i + j] = u + t; a[i + j + l / 2] = u - t; w = w * wn; } } } if (f == -1)rep(i, n)a[i].r /= n;}Complex a[MAXN], b[MAXN], ans[MAXN];char C[] = { 'A','C','G','T' };int d;int sum[MAXN], SUM = 0;void solve() { cin &gt;&gt; n2 &gt;&gt; n1 &gt;&gt; k &gt;&gt; t &gt;&gt; s; reverse(s.begin(), s.end()); while (n &lt; n1 + n2)n *= 2, len++; rep(i, n)rev[i] = (rev[i / 2] / 2 | ((i &amp; 1) &lt;&lt; (len - 1))); rep(c, 4) { rep(i, n1)S[i] = (s[i] == C[c]); d = 0; rep(i, min(k, n2))d += (t[i] == C[c]); rep(i, n2) { if (i + k &lt; n2)d += (t[i + k] == C[c]); T[i] = (d &gt; 0 ? 1 : 2); if (i - k &gt;= 0)d -= (t[i - k] == C[c]); } rep(i, n)a[i] = Complex(S[i] * S[i] * S[i], 0), b[i] = Complex(T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = a[i] * b[i]; rep(i, n)a[i] = Complex(S[i] * S[i], 0), b[i] = Complex(T[i] * T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = ans[i] - Complex(2, 0) * a[i] * b[i]; rep(i, n)a[i] = Complex(S[i], 0), b[i] = Complex(T[i] * T[i] * T[i], 0); FFT(a, 1), FFT(b, 1); rep(i, n)ans[i] = ans[i] + a[i] * b[i]; FFT(ans, -1); forr(i, n1 - 1, n2 - 1)if (fabs(ans[i].r) &lt;= 1)sum[i - n1 + 1]++; } rep(i, n2 - n1 + 1)if (sum[i] == 4)SUM++; cout &lt;&lt; SUM;}int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); T_ = 1; for (case_ = 1;case_ &lt;= T_;case_++)solve(); return 0;}","link":"/2023/01/06/FFT%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"title":"URAL1095 Nikifor 3","text":"题目传送门 首先你得先打个表，就像这样： 123456int a[] = { 1,2,3,4 };do { int x = 0; rep(i, 4) cout &lt;&lt; a[i], x = x * 10 + a[i]; cout &lt;&lt; ' ' &lt;&lt; x % 7 &lt;&lt; endl;} while (next_permutation(a, a + 4)); 然后你就能惊讶地发现，对于每个 $i\\in [1,7]$，都有至少一个 $1,2,3,4$ 的排列满足：$(组成的四位数)\\equiv i\\pmod i$。 所以考虑先在字符串中去掉 $1,2,3,4$，将剩余的所有数字放在最后面，并处理出这串数 $\\bmod 7$ 是多少，然后把 $1,2,3,4$ 按照某种顺序放在最前面就行了。 之所以要把剩余部分放在最后面而不是最前面的原因是，如果有这样一组数据：001234，就会出现前导零。 Code 12345678910111213141516171819202122232425262728293031323334353637int T_, case_;int A[7][4], sum, p;string s, t;bool f[5];void solve() { sum = 0; init(f, 0); cin &gt;&gt; s; t = &quot;&quot;; p = 1; rep(i, s.size()) { int x = s[i] - '0'; if (x &gt;= 1 &amp;&amp; x &lt;= 4 &amp;&amp; !f[x])f[x] = 1; else { t += s[i]; p = p * 10 % 7; sum = (sum * 10 + x) % 7; } } rep(i, 7)if ((i * p + sum) % 7 == 0) { rep(j, 4)cout &lt;&lt; A[i][j]; cout &lt;&lt; t &lt;&lt; endl; }}int main() { init(A, -1); int a[] = { 1,2,3,4 }; do { int x = 0; rep(i, 4) x = x * 10 + a[i]; if (A[x % 7][0] == -1)rep(i, 4)A[x % 7][i] = a[i]; } while (next_permutation(a, a + 4)); T_ = 1; cin &gt;&gt; T_; for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;}","link":"/2023/01/06/URAL1095-Nikifor-3/"},{"title":"UVA1063 Marble Game","text":"题目传送门 说是题解其实是 debug 记（叹气） 显然 BFS，状态我是用 vector&lt;vector&lt;int&gt;&gt; 来存每个格子上的 Marble 编号，洞可以根据这个推出来，就不用存。 转移时，枚举向四个方向移动。这里写四个函数可能会比较烦，我的做法是，对于 $n\\in [0,4]$，先将盘面顺时针转 $n\\cdot 90^\\circ$，再将所有 Marble 向左移动，最后将盘面顺时针旋转 $(4-n)\\cdot 90^\\circ$。 注意： 旋转时，Marble，洞和墙都要旋转。 移动时，如果 Marble 掉进了对应的洞里，就把这个 Marble 和洞都删掉，如果掉进了别人的洞里，就不进行这个方向的转移。 输出格式，impossible 首字母小写，如果答案是 1 仍然是 moves 而不是 move。 然后，我就 WA 啦。 找 gzy 的程序对拍了下，放一下生成数据的代码： 1234567891011121314151617181920212223242526272829303132333435363738int a[5][5], b[5][5], cnt;int x[16];template &lt;class T&gt;T randint(T l, T r = 0) { static mt19937 eng(time(0)); if (l &gt; r) swap(l, r); uniform_int_distribution&lt;T&gt; dis(l, r); return dis(eng);}int dx[] = { -1,0,0,1 };int dy[] = { 0,-1,1,0 };void solve() { rep(T, 1000) { rep(i, 16)x[i] = i; random_shuffle(x, x + 16); cnt = 0; rep(i, 4)rep(j, 4)a[i][j] = x[cnt++]; rep(i, 16)x[i] = i; random_shuffle(x, x + 16); cnt = 0; rep(i, 4)rep(j, 4)b[i][j] = x[cnt++]; int M = randint(1, 8), W = randint(0, 10); bool f = 0; rep(i, 4)rep(j, 4)if (a[i][j] &lt; M &amp;&amp; b[i][j] &lt; M)f = 1; if (f == 1)continue; cout &lt;&lt; 4 &lt;&lt; ' ' &lt;&lt; M &lt;&lt; ' ' &lt;&lt; W &lt;&lt; endl; rep(s, M) rep(i, 4)rep(j, 4)if (a[i][j] == s)cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; endl; rep(s, M) rep(i, 4)rep(j, 4)if (b[i][j] == s)cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; endl; while (W--) { int A = randint(1, 2), B = randint(1, 2), C = randint(0, 3); cout &lt;&lt; A &lt;&lt; ' ' &lt;&lt; B &lt;&lt; ' ' &lt;&lt; A + dx[C] &lt;&lt; ' ' &lt;&lt; B + dy[C] &lt;&lt; endl; } } cout &lt;&lt; &quot;0 0 0\\n&quot;;} 拍出来几个问题： 输入数据中下标是从 0 开始的 多测记得清空 每次移动后，Marble 和洞都要还原成移动前的位置 记录每个 Marble 是否出现的数组要开至少 8 大小 拍出来问题的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Input 14 3 70 12 00 32 11 13 22 2 3 21 2 1 31 1 2 12 1 2 22 2 3 22 2 3 21 2 1 1Output 1impossibleInput 24 8 90 01 02 03 03 13 23 32 31 22 22 11 10 10 20 31 30 0 0 11 0 1 12 0 2 12 1 3 12 2 3 22 2 2 31 2 1 30 2 1 21 1 1 2Output 225 moves Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100int n, m, w, A, B, C, D;bool operator&lt;(vector&lt;vector&lt;int&gt;&gt; A, vector&lt;vector&lt;int&gt;&gt; B) { repp(i, n)repp(j, n)if (A[i][j] != B[i][j])return A[i][j] &lt; B[i][j]; return 0;}bool operator==(vector&lt;vector&lt;int&gt;&gt; A, vector&lt;vector&lt;int&gt;&gt; B) { repp(i, n)repp(j, n)if (A[i][j] != B[i][j])return 0; return 1;}vector&lt;vector&lt;int&gt;&gt; a(5), b(5), x(5), y(5), cpy(5);bool f[5][5][5][5], f_[5][5][5][5], F[100];map&lt;vector&lt;vector&lt;int&gt;&gt;, int&gt;vis;void rotate(int N) { while (N--) { repp(i, n)repp(j, n)cpy[i][j] = x[n + 1 - j][i]; x = cpy; repp(i, n)repp(j, n)cpy[i][j] = y[n + 1 - j][i]; y = cpy; repp(i1, n)repp(j_1, n)repp(i2, n)repp(j2, n)f_[i1][j_1][i2][j2] = f[n + 1 - j_1][i1][n + 1 - j2][i2]; repp(i1, n)repp(j_1, n)repp(i2, n)repp(j2, n)f[i1][j_1][i2][j2] = f_[i1][j_1][i2][j2]; }}bool move() { repp(i, n) { repp(j, n) { if (!x[i][j])continue; int k = j; while (k &gt; 1 &amp;&amp; !f[i][k - 1][i][k] &amp;&amp; !x[i][k - 1]) { x[i][k - 1] = x[i][k]; x[i][k] = 0; k--; if (y[i][k] == x[i][k]) { x[i][k] = y[i][k] = 0; break; } if (y[i][k] &amp;&amp; y[i][k] != x[i][k])return 0; } } } return 1;}int bfs() { queue&lt;pair&lt;vector&lt;vector&lt;int&gt;&gt;, int&gt;&gt;q; q.push(mp(a, 0)); vis[a] = T_; while (!q.empty()) { x = q.front().fi; int val = q.front().se; q.pop(); init(F, 0); bool tmp = 0; repp(i, n)repp(j, n)if (x[i][j])F[x[i][j]] = tmp = 1; if (!tmp)return val; repp(i, n)repp(j, n) { if (F[b[i][j]])y[i][j] = b[i][j]; else y[i][j] = 0; } vector&lt;vector&lt;int&gt;&gt;xx = x, yy = y; bool suc; suc = move(); if (suc &amp;&amp; vis[x] != T_)q.push(mp(x, val + 1)), vis[x] = T_; x = xx, y = yy; rotate(1); suc = move(); rotate(3); if (suc &amp;&amp; vis[x] != T_)q.push(mp(x, val + 1)), vis[x] = T_; x = xx, y = yy; rotate(2); suc = move(); rotate(2); if (suc &amp;&amp; vis[x] != T_)q.push(mp(x, val + 1)), vis[x] = T_; x = xx, y = yy; rotate(3); suc = move(); rotate(1); if (suc &amp;&amp; vis[x] != T_)q.push(mp(x, val + 1)), vis[x] = T_; } return -1;}void solve() { repp(i, n)a[i].resize(5), b[i].resize(5), x[i].resize(5), y[i].resize(5), cpy[i].resize(5); repp(i, n)repp(j, n)a[i][j] = b[i][j] = 0; repp(i, n)repp(j, n)repp(ii, n)repp(jj, n)f[i][j][ii][jj] = 0; repp(i, m) { cin &gt;&gt; A &gt;&gt; B; a[A + 1][B + 1] = i; } repp(i, m) { cin &gt;&gt; A &gt;&gt; B; b[A + 1][B + 1] = i; } repp(i, w) { cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D; A++, B++, C++, D++; f[A][B][C][D] = f[C][D][A][B] = 1; } int ans = bfs(); if (ans == -1) cout &lt;&lt; &quot;Case &quot; &lt;&lt; T_ &lt;&lt; &quot;: impossible\\n\\n&quot;; else cout &lt;&lt; &quot;Case &quot; &lt;&lt; T_ &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; &quot; moves\\n\\n&quot;;}","link":"/2023/01/06/UVA1063-Marble-Game/"},{"title":"一些trick","text":"枚举子集枚举 $i$ 在二进制下的的所有子集 $j$（即 $i &amp; j=j$） 1234for(int j=i;;j=(j-1)&amp;i){ // something here if(!j)break;} 顺便说一下，$\\sum\\limits_{i=1}^{2^n}2^{\\operatorname{popcount}(i)}=O(3^n)$ splay 求 x 节点的 rk有时 val 不满足 $左&lt;根&lt;右$ 时（比如文艺平衡树），无法正常实现 rk 可以先把 x splay 至根，然后求根的左子树 siz 注意树上有标记时要先把 x 的祖先按深度从小到大顺序 pushdown tag 区间覆盖 dp每个区间转成两个端点处的差分（l+1,(r+1)-1），记录当前的前缀和 dp。","link":"/2023/01/06/%E4%B8%80%E4%BA%9Btrick/"},{"title":"斯涅尔定律最愚蠢的证法","text":"2022 年整的最后一个活。 问题平面直角坐标系上有两点 $S(0,h_1)$ 和 $T(w,h_2)$ 满足 $h_1&gt;0,h_2&lt;0$，一个动点 $P$ 从 $S$ 出发移动到 $T$。$P$ 在 $x$ 轴上方时的速度为 $v_1$，在 $x$ 轴下方时的速度为 $v_2$，求时间最短的路径。 斯涅尔定律：$\\dfrac{\\sin(\\theta_1)}{v_1}=\\dfrac{\\sin(\\theta_2)}{v_2}$ 证明显然，路径为两条线段组成的折线，转折点在 $x$ 轴上。 设折线与 $x$ 轴交点位于 $(0,x)$。 容易得出路径长度的函数 $f(x)$：$$f(x)=\\dfrac{\\sqrt{h_1^2+x^2}}{v}+\\dfrac{\\sqrt{h_2^2+(w-x)^2}}{v2}$$ 当取 $h_1=3,h_2=5,w=10,v_1=3,v_2=1$ 时，函数图像长这个样子： 发现它是一个单谷函数，它的最小值就是唯一的极小值。所以求导： $$f’(x)=\\dfrac{v_2x\\sqrt{(w-x)^2+h_2^2}-v_1(w-x)\\sqrt{x^2+h_1^2}}{v_1v_2\\sqrt{x^2+h_1^2}\\sqrt{(w-x)^2+h_2^2}}$$ 最小值点的导数为 $0$，所以得出： $$v_2x\\sqrt{(w-x)^2+h_2^2}=v_1(w-x)\\sqrt{x^2+h_1^2}$$ $$\\dfrac{x\\sqrt{(w-x)^2+h_2^2}}{(w-x)\\sqrt{x^2+h_1^2}}=\\dfrac{v_1}{v_2}$$ $$\\dfrac{x}{\\sqrt{x^2+h_1^2}}:\\dfrac{w-x}{\\sqrt{(w-x)^2+h_2^2}}=v_1:v_2$$ $$\\dfrac{SP}{SM}:\\dfrac{QT}{MT}=v_1:v_2$$ $$\\dfrac{\\sin(\\theta_1)}{v_1}=\\dfrac{\\sin(\\theta_2)}{v_2}$$ 证毕。","link":"/2023/01/06/%E6%96%AF%E6%B6%85%E5%B0%94%E5%AE%9A%E5%BE%8B%E6%9C%80%E6%84%9A%E8%A0%A2%E7%9A%84%E8%AF%81%E6%B3%95/"},{"title":"百度之星2022初赛游记","text":"做的是第二场。 看别人打的第一场做了 7 题还 100+ 名，一开题感觉一道都不会做，很慌。 最后做出来 5 题，66 名，很开心。 做题顺序：$1\\rightarrow 3 \\rightarrow 7 \\rightarrow 5 \\rightarrow 4$ 这场显然偶数题比奇数题难。 1. 和题意给定一个长为 $n$ 的序列，有 $q$ 次询问，每次询问 $[l,r]$ 区间内最大的 $k$ 个数之和是否 $\\ge x$。 $n,q \\le 10^5,k\\le 10,a_i \\le 10^4,x\\le 10^8$ 做法第一遍写了莫队，用 set 维护，显而易见 TLE 了。（不过这个我还写了好久 /lh） 由于 $k$ 十分小，所以用线段树维护区间内前 $k$ 小的值，合并什么的总之就是非常暴力。 复杂度 $O(nk \\log k+qk\\log nk)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i, n) forr(i, 0, n-1)#define repp(i, n) forr(i, 1, n)#define pb push_back#define mp make_pair#define init(a, i) memset(a, i, sizeof(a))#define fi first#define se second#define MAXN 0x3f3f3f3f#define ls node*2+1#define rs node*2+2int T_ = 1, case_;int a[100005];int n, q, k, x;int tree[400005][21], cnt[400005];void build(int node, int l, int r) { if (l == r) { cnt[node] = 1; tree[node][0] = a[l]; return; } int mid = l + r &gt;&gt; 1; build(ls, l, mid); build(rs, mid + 1, r); cnt[node] = 0; rep(i, cnt[ls])tree[node][cnt[node]++] = tree[ls][i]; rep(i, cnt[rs])tree[node][cnt[node]++] = tree[rs][i]; sort(tree[node], tree[node] + cnt[node]); reverse(tree[node], tree[node] + cnt[node]); cnt[node] = min(cnt[node], k);}vector&lt;int&gt;ans;void query(int node, int l, int r, int L, int R) { if (L &lt;= l &amp;&amp; r &lt;= R) { rep(i, cnt[node])ans.pb(tree[node][i]); return; } int mid = l + r &gt;&gt; 1; if (mid &gt;= L)query(ls, l, mid, L, R); if (mid &lt; R)query(rs, mid + 1, r, L, R);}int l, r, sum;void solve() { cin &gt;&gt; n &gt;&gt; q &gt;&gt; k &gt;&gt; x; rep(i, n)cin &gt;&gt; a[i]; build(0, 0, n - 1); while (q--) { cin &gt;&gt; l &gt;&gt; r; ans.clear(); query(0, 0, n - 1, l - 1, r - 1); sum = 0; sort(ans.begin(), ans.end()); reverse(ans.begin(), ans.end()); rep(i, min((int)ans.size(), k))sum += ans[i]; if (sum &gt;= x)cout &lt;&lt; &quot;Y\\n&quot;; else cout &lt;&lt; &quot;N\\n&quot;; }}int main() { // ios::sync_with_stdio(0); // cin.tie(0), cout.tie(0); // cin &gt;&gt; T_; for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;} 3. 逃离这棵树题意给定一棵大小为 $n$ 的树，根节点为 $1$，每个点有权重 $p_i$，$i$ 到 $j$ 的边有权重 $q_{i,j}$。 当站在点 $i$ 上时，下一步有 $\\frac{p_i}{p_i+\\sum q_{i,j}}$ 的概率留在原地，有 $\\frac{q_{i,j}}{p_i+\\sum q_{i,j}}$ 的概率到 $j$ 节点（$j$ 为 $i$ 的儿子）。 初始时在根节点，问期望多少步后到达叶节点，对 $998244353$ 取模。 $n \\le 10^6,p_i,q_{i,j}\\le 10$ 做法做法类似于某场 ABC 的 E 题，只是把数轴换成了树。然而我至今没有补掉那个题，但是赛时把这个题切了。 设 $dp_i$ 为 $i$ 期望走多少步到叶节点。 考虑枚举从 $i$ 下一步到达的点 $j$，$j$ 对 $i$ 的答案的贡献是 $\\frac{q_{i,j}}{p_i+\\sum q_{i,j}} \\cdot dp_j$。 另外，$i$ 节点期望要 $\\frac{p_i+\\sum q_{i,j}}{p_i}$ 步离开原地，所以 $dp_i$ 还要再加上这个数。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i, n) forr(i, 0, n-1)#define repp(i, n) forr(i, 1, n)#define pb push_back#define mp make_pair#define init(a, i) memset(a, i, sizeof(a))#define fi first#define se second#define MAXN 0x3f3f3f3fint T_ = 1, case_;const int MOD = 998244353;ll qpow(ll x, ll y) { ll p = 1; while (y) { if (y &amp; 1)p = p * x % MOD; x = x * x % MOD; y &gt;&gt;= 1; } return p;}ll inv(ll x) { return qpow(x, MOD - 2); }int n, p[1000006], q[1000006];vector&lt;vector&lt;int&gt;&gt;v;ll dp[1000006];void dfs(int x) { if (v[x].empty()) { dp[x] = 0; return; } ll sum = 0; for (int y : v[x]) { dfs(y); sum += q[y]; } ll INV = inv(sum); dp[x] = (sum + p[x]) * INV; for (int y : v[x])dp[x] = (dp[x] + q[y] * INV % MOD * dp[y] % MOD) % MOD;}void solve() { cin &gt;&gt; n; rep(i, n) cin &gt;&gt; p[i]; v.resize(n); repp(i, n - 1) { int a; cin &gt;&gt; a &gt;&gt; q[i]; v[a - 1].pb(i); } dfs(0); cout &lt;&lt; dp[0];}int main() { // ios::sync_with_stdio(0); // cin.tie(0), cout.tie(0); // cin &gt;&gt; T_; for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;} 4. 通信网络题意给定一个 $n$ 个点，$m$ 条边的无向图，一条边 $(u,v,w)$ 表示这条边连接 $u$ 和 $v$，长度为 $w$。有 $q$ 次询问，每次询问给定 $k$ 个关键点，第 $i$ 个关键点为 $p_i$，与这个点的距离 $\\le d_i$ 的节点会被打上标记。对于每次询问，输出有多少个点被打上了标记。询问之间独立，也就是每次打上的标记会在下一次询问前清空。 $n \\le 10^3,m \\le 10^4,q \\le 10^5,\\sum k \\le 10^6,w \\le 10^6,d_i \\le 10^9$ 做法把询问离线下来，对于每个关键点分别处理。 对于每个询问一个 bitset $ans_i$，$ans_{i,j}$ 表示在第 $i$ 次询问中，$j$ 是否被打上了标记。 对于每个关键点 $x$，把和它有关的询问按照 $d$ 从小到大排序。 维护一个 bitset $res$，$res_i$ 表示 $i$ 与 $x$ 的距离是否 $\\le d$。容易发现，由于 $d$ 已经从小到大排序过了，所以 $res$ 中的元素只会从 $0$ 变成 $1$，或者不变。 所以先跑一边 dijkstra，处理出所有点到 $x$ 的距离，然后把所有点按照与 $x$ 的距离排序，单调地往 $res$ 中加入就可以了。处理到第 $i$ 个询问时，把 $ans_i$ 按位或上 $res$，最后答案就是 $ans_i.count()$。 复杂度 $O(n^2\\log n+nm \\log m+k \\log k+\\frac{nk}{\\omega})$，能过。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i, n) forr(i, 0, n-1)#define repp(i, n) forr(i, 1, n)#define pb push_back#define mp make_pair#define init(a, i) memset(a, i, sizeof(a))#define fi first#define se second#define MAXN 0x3f3f3f3fint T_ = 1, case_;int n, m, q, a, b, c;int dist[1010];int k;vector&lt;pair&lt;int, int&gt;&gt;g[1010], v[1010];bitset&lt;1010&gt;ans[100005], tmp;priority_queue&lt;pair&lt;int, int&gt;&gt;pq;int id[1010];void solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; rep(i, m) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; a--, b--; g[a].pb(mp(b, c)); g[b].pb(mp(a, c)); } rep(i, q) { cin &gt;&gt; k; rep(j, k) { cin &gt;&gt; a &gt;&gt; b; v[a - 1].pb(mp(b, i)); } } rep(i, n) { if (v[i].empty())continue; init(dist, 63); dist[i] = 0; pq.push(mp(0, i)); while (!pq.empty()) { int val = -pq.top().fi, x = pq.top().se; pq.pop(); if (val != dist[x])continue; if (g[x].size())rep(j, g[x].size()) { int y = g[x][j].fi, w = g[x][j].se; if (dist[y] &gt; val + w) { dist[y] = val + w; pq.push(mp(-dist[y], y)); } } } tmp.reset(); rep(i, n)id[i] = i; sort(id, id + n, [&amp;](int x, int y) {return dist[x] &lt; dist[y];}); sort(v[i].begin(), v[i].end()); int p = 0; rep(j, v[i].size()) { while (p &lt; n &amp;&amp; dist[id[p]] &lt;= v[i][j].fi) { tmp[id[p]] = 1; p++; } ans[v[i][j].se] |= tmp; } } rep(i, q)cout &lt;&lt; ans[i].count() &lt;&lt; endl;}int main() { // ios::sync_with_stdio(0); // cin.tie(0), cout.tie(0); // cin &gt;&gt; T_; for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;} 5. 星球联通题意给定三维空间内的 $n$ 个点，表示一个点的坐标为 $(x,y,z)$，连接两个点的代价是它们距离的平方。 现在可以免费连接 $k$ 个点，额外再连接 $i$ 个点（即一共连接 $k+i$ 个点）需要花 $c_i$ 的代价。 求将所有点连通起来的最小代价。 $k \\le n \\le 3000,c_i \\le 10^9,x,y,z \\le 10^4$ 做法显然枚举额外连接多少个星球，现在问题变成： 给定一张带权完全图，连接其中 $x$ 个点，代价最少是多少。 容易联想到最小生成树的 Kruskal 算法。改一下： 把边按边权从小到大依次检查，如果连接的两个点不在同一个连通分量里，就把这条边加进去。当有 $x-1$ 条边时结束。 这个看上去就很对的算法实际上也是对的，正确性易证，但是我不会证，大概和 Kruskal 的证法差不多。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i, n) forr(i, 0, n-1)#define repp(i, n) forr(i, 1, n)#define pb push_back#define mp make_pair#define init(a, i) memset(a, i, sizeof(a))#define fi first#define se second#define MAXN 0x3f3f3f3f3f3f3f3fint T_ = 1, case_;ll n, k, c[3010], x[3010], y[3010], z[3010], ans, sum, cnt;vector &lt; pair&lt;ll, pair&lt;int, int&gt;&gt;&gt;v;int fa[3010];int getf(int i) { if (fa[i] == i)return i; return fa[i] = getf(fa[i]);}void solve() { cin &gt;&gt; n &gt;&gt; k; repp(i, n - k)cin &gt;&gt; c[i]; rep(i, n)cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; z[i]; rep(i, n)forr(j, i + 1, n - 1) { ll X = x[i] - x[j], Y = y[i] - y[j], Z = z[i] - z[j]; ll val = X * X + Y * Y + Z * Z; v.pb(mp(val, mp(i, j))); } sort(v.begin(), v.end()); rep(i, n)fa[i] = i; ans = c[n - k], sum = 0, cnt = n - k; rep(i, v.size()) { int a = v[i].se.fi, b = v[i].se.se; if (getf(a) == getf(b))continue; cnt--; fa[getf(a)] = getf(b); sum += v[i].fi; ans = min(ans, sum + c[cnt]); if (!cnt)break; } cout &lt;&lt; ans;}int main() { // ios::sync_with_stdio(0); // cin.tie(0), cout.tie(0); // cin &gt;&gt; T_; for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;} 7. 原地传送题意有一个 $n\\times m$ 的网格图，起点为 $(0,0)$，终点为 $(n,m)$，每次可以从 $(x,y)$ 走到 $(x+1,y)$ 或 $(x,y+1)$。 有 $k$ 个传送门，第 $i$ 个传送门在 $(x_i,y_i)$，碰到传送门就必须要立即移动到另一个传送门（不能原地传送）。 求有多少种恰好传送一次后到达终点的行走方案。 $n,m \\le 10^5,k \\le 2000$ 做法枚举传送的起点和终点是哪两个传送门，问题转化成： 有多少种方法从起点走到传送门 $i$ / 从传送门 $i$ 走到终点，中途不碰到任何其它的传送门。 考虑从起点走到传送门 $i$ 的情况，另一种同理。 设 $i$ 的答案是 $dp_i$，$cnt(a,b)$ 表示向 $x$ 方向走 $a$ 步，向 $y$ 方向走 $b$ 步的方案数。 易得 $cnt(a,b)=\\binom{a+b}{a}$。 如果不考虑 “中途不碰到任何其它的传送门” 这一条件，那么 $dp_i=cnt(x_i,y_i)$。 枚举第一个碰到的传送门 $j$，从起点走到 $j$ （中途不碰到任何其它的传送门）有 $dp_j$ 种方案，从 $j$ 走到 $i$（因为已经确定了第一个碰到的，所以后面就没有限制条件了）有 $cnt(x_i-x_j,y_i-y_j)$ 种方案，所以 $dp_i$ 要减去 $dp_j \\cdot cnt(x_i-x_j,y_i-y_j)$。 然后发现只有在 $x_j\\le x_i$ 且 $y_j \\le y_i$ 时这个转移才有效，所以把所有坐标按照 $x+y$ 从小到大排序，计算 $dp_i$ 时只要考虑所有 $j&lt;i$。 复杂度 $O(n^2)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* Code by Reflective-FG */#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define forr(i, a, b) for (int i = a; i &lt;= b; i++)#define rep(i, n) forr(i, 0, n-1)#define repp(i, n) forr(i, 1, n)#define pb push_back#define mp make_pair#define init(a, i) memset(a, i, sizeof(a))#define fi first#define se second#define MAXN 0x3f3f3f3fint T_ = 1, case_;int n, m, r, c, a[20][20];vector&lt;int&gt;v;int cost1[20][20], cost2[20], dp[20][20], ans = MAXN;void solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; c; rep(i, n)rep(j, m)cin &gt;&gt; a[i][j]; repp(w, (1 &lt;&lt; m) - 1) { v.clear(); rep(i, m)if ((w &gt;&gt; i) &amp; 1)v.pb(i); if ((int)v.size() != c)continue; rep(i, n)forr(j, i + 1, n - 1) { cost1[i][j] = 0; rep(k, c)cost1[i][j] += abs(a[i][v[k]] - a[j][v[k]]); } rep(i, n) { cost2[i] = 0; rep(j, c - 1)cost2[i] += abs(a[i][v[j]] - a[i][v[j + 1]]); } init(dp, 63); rep(i, n) { dp[i][0] = 0, dp[i][1] = cost2[i]; forr(j, 2, i + 1)rep(k, i)dp[i][j] = min(dp[i][j], dp[k][j - 1] + cost1[k][i] + cost2[i]); ans = min(ans, dp[i][r]); } } cout &lt;&lt; ans;}int main() { // ios::sync_with_stdio(0); // cin.tie(0), cout.tie(0); // cin &gt;&gt; T_; for (case_ = 1; case_ &lt;= T_; case_++)solve(); return 0;} 写在最后感觉这场比赛都是第一眼很吓人，仔细想想其实还好的题。 大家来了应该都能爆切吧。 QwQ","link":"/2023/01/06/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F2022%E5%88%9D%E8%B5%9B%E6%B8%B8%E8%AE%B0/"}],"tags":[],"categories":[{"name":"比赛笔记","slug":"比赛笔记","link":"/categories/%E6%AF%94%E8%B5%9B%E7%AC%94%E8%AE%B0/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"}],"pages":[]}